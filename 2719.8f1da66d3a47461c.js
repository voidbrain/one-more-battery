(self.webpackChunkapp=self.webpackChunkapp||[]).push([[2719],{22719:(Tt,ts,Y)=>{"use strict";Y.r(ts),Y.d(ts,{BackendWasm:()=>Ro,getThreadsCount:()=>Bi,setThreadsCount:()=>Ei,setWasmPath:()=>Ti,setWasmPaths:()=>Pi,version_wasm:()=>Oi});var o=Y(41653),B=function(r){return r[r.float32=0]="float32",r[r.int32=1]="int32",r[r.bool=2]="bool",r[r.string=3]="string",r[r.complex64=4]="complex64",r}(B||{}),re=function(r){return r[r.linear=0]="linear",r[r.relu=1]="relu",r[r.relu6=2]="relu6",r[r.prelu=3]="prelu",r[r.leakyrelu=4]="leakyrelu",r[r.sigmoid=5]="sigmoid",r[r.elu=6]="elu",r}(re||{});let t;const ke={kernelName:o.Dr,backendName:"wasm",setupFunc:function Te(r){t=r.wasm.cwrap(o.Dr,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])},kernelFunc:function rt(r){const{inputs:n,backend:s,attrs:c}=r,{a,b:i,bias:p,preluActivationWeights:l}=n;if("float32"!==a.dtype||"float32"!==i.dtype)throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");const{transposeA:f,transposeB:d,activation:u,leakyreluAlpha:h}=c,v=s.dataIdMap.get(a.dataId).id,g=s.dataIdMap.get(i.dataId).id;let b=0;if(null!=p){const X=s.dataIdMap.get(p.dataId);if(1!==X.shape.length)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${X.shape.length}.`);b=X.id}const y=null==l?0:s.dataIdMap.get(l.dataId).id,S=re[u];if(null==S)throw new Error(`${u} activation not yet supported for FusedConv2D in the wasm backend.`);const A=f?a.shape[2]:a.shape[1],w=d?i.shape[1]:i.shape[2],k=o.ZEY.assertAndGetBroadcastShape(a.shape.slice(0,-2),i.shape.slice(0,-2)),C=s.makeOutput([...k,A,w],a.dtype),z=s.dataIdMap.get(C.dataId).id,H=new Uint8Array(new Int32Array(a.shape).buffer),G=new Uint8Array(new Int32Array(i.shape).buffer);return t(v,H,a.shape.length,g,G,i.shape.length,f,d,S,b,y,h||0,z),C}};function O(r,n){let s;return{kernelName:r,backendName:"wasm",setupFunc:function c(i){s=i.wasm.cwrap(r,null,["number","number","number"])},kernelFunc:function a(i){const{backend:p,inputs:{x:l}}=i,f=p.dataIdMap.get(l.dataId).id,d=p.makeOutput(l.shape,n||l.dtype),u=p.dataIdMap.get(d.dataId).id;return 0===o.ZSL.sizeFromShape(d.shape)||s(f,B[l.dtype],u),d}}}const Pt=O(o.ljI),st=O(o.Vvy),e=O(o.PH8);function Z(r,n,s){let c;return{kernelName:r,backendName:"wasm",setupFunc:function a(p){c=p.wasm.cwrap(r,null,["number","array","number","number","array","number","number","number"])},kernelFunc:function i(p){const{backend:l,inputs:f}=p,{a:d,b:u}=f,h=l.dataIdMap.get(d.dataId).id,v=l.dataIdMap.get(u.dataId).id,g=null!=s?s:d.dtype,b=o.C0T.assertAndGetBroadcastShape(d.shape,u.shape),y=l.makeOutput(b,g);if(0===o.ZSL.sizeFromShape(b))return y;const S=new Uint8Array(new Int32Array(d.shape).buffer),A=new Uint8Array(new Int32Array(u.shape).buffer),w=l.dataIdMap.get(y.dataId).id;return c(h,S,d.shape.length,v,A,u.shape.length,B[d.dtype],w),y}}}const We=Z(o.OMN);let ie;const xe={kernelName:o.EkD,backendName:"wasm",setupFunc:function ot(r){ie=r.wasm.cwrap(o.EkD,null,["array","number","number","number"])},kernelFunc:function Ke(r){const{inputs:n,backend:s}=r,c=s.makeOutput(n[0].shape,n[0].dtype);if(0===o.ZSL.sizeFromShape(c.shape))return c;const a=n.map(l=>s.dataIdMap.get(l.dataId).id),i=new Uint8Array(new Int32Array(a).buffer),p=s.dataIdMap.get(c.dataId).id;return ie(i,a.length,B[c.dtype],p),c}};function Ie(r){const{inputs:{x:n},backend:s}=r;if("string"===n.dtype)return(0,o.OEK)(s.readSync(n.dataId),n.shape,n.dtype);const c=s.makeOutput(n.shape,n.dtype),a=s.typedArrayFromHeap(n);return s.typedArrayFromHeap(c).set(a),c}const De={kernelName:o.lzr,backendName:"wasm",kernelFunc:Ie};let de;function J(r){const{inputs:n,backend:s,attrs:c}=r,[a,i]=function ve(r,n){const s=[],c=[];for(let a=0;a<r.length;++a)1!==r[a]&&s.push(r[a]),1!==r[n[a]]&&c.push(n[a]);for(let a=0;a<c.length;++a){let i=-1;for(let p=0;p<c.length;++p)c[p]>=a&&(-1===i||c[i]>c[p])&&(i=p);c[i]=a}return[s,c]}(n.x.shape,c.perm);let p=!0;for(let b=0;b<i.length;b++)i[b]!==b&&(p=!1);const l=function Et(r,n){const s=new Array(r.length);for(let c=0;c<s.length;c++)s[c]=r[n[c]];return s}(n.x.shape,c.perm),f={dataId:n.x.dataId,shape:a,dtype:n.x.dtype};if(p){const b=Ie({inputs:n,backend:s});return b.shape=l,b}const d=s.makeOutput(l,f.dtype),u=s.dataIdMap.get(f.dataId).id,h=s.dataIdMap.get(d.dataId).id,v=new Uint8Array(new Int32Array(i).buffer),g=new Uint8Array(new Int32Array(f.shape).buffer);return de(u,g,f.shape.length,B[f.dtype],h,v,i.length),d}const ut={kernelName:o.wx0,backendName:"wasm",kernelFunc:J,setupFunc:function ee(r){de=r.wasm.cwrap(o.wx0,null,["number","array","number","number","number","array","number"])}};function ce(r,n,s){const c=r.shape,a=r.shape.length,i=o.ZSL.parseAxisParam(n,c);let p=i;const l=o.C0T.getAxesPermutation(p,a);let f=null,d=!1;if(null!=l){const u=new Array(a);for(let g=0;g<u.length;g++)u[g]=c[l[g]];p=o.C0T.getInnerMostAxes(p.length,a),f=J({inputs:{x:r},attrs:{perm:l},backend:s});const h=s.dataIdMap.get(r.dataId).id;s.dataIdMap.get(f.dataId).id!==h&&(d=!0)}return{transposed:f,originalAxes:i,axes:p,inputWasTransposed:d}}let Bt;const it={kernelName:o.u8Z,backendName:"wasm",setupFunc:function Je(r){Bt=r.wasm.cwrap(o.u8Z,null,["number, number, number"])},kernelFunc:function He(r){const{backend:n,inputs:s,attrs:c}=r,{axis:a,keepDims:i}=c,{x:p}=s;let f=n.dataIdMap.get(p.dataId).id,d=p;const{transposed:u,axes:h,originalAxes:v,inputWasTransposed:g}=ce(p,a,n);g&&(d=u,f=n.dataIdMap.get(u.dataId).id),o.C0T.assertAxesAreInnerMostDims("all",h,d.shape.length);const[y,S]=o.C0T.computeOutAndReduceShapes(d.shape,h),A=o.ZSL.sizeFromShape(S),w=n.makeOutput(y,p.dtype);if(0!==o.ZSL.sizeFromShape(d.shape)){const k=n.dataIdMap.get(w.dataId).id;Bt(f,A,k)}if(g&&n.disposeData(u.dataId),i){const k=o.C0T.expandShapeToKeepDim(w.shape,v);w.shape=k}return w}};let Ot;const se={kernelName:o.FSt,backendName:"wasm",setupFunc:function dt(r){Ot=r.wasm.cwrap(o.FSt,null,["number, number, number"])},kernelFunc:function ct(r){const{backend:n,inputs:s,attrs:c}=r,{axis:a,keepDims:i}=c,{x:p}=s;let f=n.dataIdMap.get(p.dataId).id,d=p;const{transposed:u,axes:h,originalAxes:v,inputWasTransposed:g}=ce(p,a,n);g&&(d=u,f=n.dataIdMap.get(u.dataId).id),o.C0T.assertAxesAreInnerMostDims("any",h,d.shape.length);const[y,S]=o.C0T.computeOutAndReduceShapes(d.shape,h),A=o.ZSL.sizeFromShape(S),w=n.makeOutput(y,p.dtype);if(0!==o.ZSL.sizeFromShape(d.shape)){const k=n.dataIdMap.get(w.dataId).id;Ot(f,A,k)}if(g&&n.disposeData(u.dataId),i){const k=o.C0T.expandShapeToKeepDim(w.shape,v);w.shape=k}return w}};function Zn(r){let n;return{kernelName:r,backendName:"wasm",setupFunc:function s(a){n=a.wasm.cwrap(r,null,["number","number","number","number","number"])},kernelFunc:function c(a){const{backend:i,inputs:p,attrs:l}=a,{axis:f}=l,{x:d}=p,u=i.dataIdMap.get(d.dataId).id;let h=u,v=d;const{transposed:g,axes:b,inputWasTransposed:y}=ce(d,f,i);if(y){const z=i.dataIdMap.get(g.dataId).id;z!==u&&(v=g,h=z)}const S=v.shape.slice(0,-1),A=i.makeOutput(S,"int32"),w=i.dataIdMap.get(A.dataId).id,k=o.ZSL.sizeFromShape(A.shape);return n(h,B[v.dtype],k,v.shape[b[0]],w),y&&i.disposeData(g.dataId),A}}}const ns=Zn(o.Jp_),qn=Zn(o.p_m),$n=O(o.QKF),ye=O(o.epO),Lt=O(o.TyE),j=Z(o.lxb),pt=O(o.zP9);let Ce;const lt={kernelName:o.ho8,backendName:"wasm",setupFunc:function ze(r){Ce=r.wasm.cwrap(o.ho8,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function Xn(r){const{inputs:n,attrs:s,backend:c}=r,a=n.x,i=c.dataIdMap.get(a.dataId).id,{filterSize:p,strides:l,pad:f,dimRoundingMode:d}=s,u=o.C0T.computePool2DInfo(a.shape,p,l,1,f,d),h=u.filterHeight,v=u.filterWidth,g=u.padInfo.top,b=u.padInfo.right,y=u.padInfo.bottom,S=u.padInfo.left,A=u.strideHeight,w=u.strideWidth,k=u.inChannels;if("channelsLast"!==u.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${u.dataFormat}'. Please use 'channelsLast'.`);if(1!==u.dilationWidth||1!==u.dilationHeight)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${u.dilationHeight}, ${u.dilationWidth}].`);const C=c.makeOutput(u.outShape,"float32"),z=c.dataIdMap.get(C.dataId).id;return Ce(i,a.shape[0],a.shape[1],a.shape[2],h,v,g,b,y,S,A,w,k,z),C}};let Wt;const Vt={kernelName:o.cS,backendName:"wasm",setupFunc:function Ht(r){Wt=r.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function zt(r){const{inputs:n,backend:s,attrs:c}=r,{x:a}=n,{filterSize:i,strides:p,pad:l,dimRoundingMode:f,dataFormat:d}=c,u=o.C0T.computePool3DInfo(a.shape,i,p,1,l,f,d),h=s.makeOutput(u.outShape,a.dtype);return Wt(s.dataIdMap.get(a.dataId).id,s.dataIdMap.get(h.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),h}};let oe;const jt={kernelName:o.wwC,backendName:"wasm",setupFunc:function Gt(r){oe=r.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function Ut(r){const{inputs:n,backend:s,attrs:c}=r,{dy:a,input:i}=n,{filterSize:p,strides:l,pad:f,dimRoundingMode:d}=c,u=o.C0T.computePool3DInfo(i.shape,p,l,1,f,d),h=s.makeOutput(i.shape,i.dtype);return oe(s.dataIdMap.get(a.dataId).id,s.dataIdMap.get(h.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left,u.filterDepth,u.filterHeight,u.filterWidth),h}};let Zt;const Xt={kernelName:o.VCH,backendName:"wasm",setupFunc:function qt(r){Zt=r.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function $t(r){const{inputs:n,backend:s,attrs:c}=r,{dy:a,input:i}=n,{filterSize:p,strides:l,pad:f}=c,d=o.C0T.computePool2DInfo(i.shape,p,l,1,f),u=s.makeOutput(i.shape,i.dtype);return Zt(s.dataIdMap.get(a.dataId).id,s.dataIdMap.get(u.dataId).id,d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.top,d.padInfo.left,d.filterHeight,d.filterWidth),u}};function ue(r){const{inputs:n,attrs:s}=r,{x:c}=n,{shape:a}=s,i=o.ZSL.sizeFromShape(c.shape),p=o.ZSL.inferFromImplicitShape(a,i);return o.ZSL.assert(i===o.ZSL.sizeFromShape(p),()=>`new shape: ${p}, old shape: ${c.shape}. New shape and old shape must have the same number of elements.`),r.backend.incRef(c.dataId),{dataId:c.dataId,shape:p,dtype:c.dtype}}const pe={kernelName:o.R23,backendName:"wasm",kernelFunc:ue};let Ve;const Jt={kernelName:o.jAQ,backendName:"wasm",setupFunc:function Pe(r){Ve=r.wasm.cwrap(o.jAQ,null,["number","array","number","number","array","number","number","number","number"])},kernelFunc:function Kt(r){const{inputs:n,backend:s,attrs:c}=r,{a,b:i}=n,{transposeA:p,transposeB:l}=c;if("float32"!==a.dtype||"float32"!==i.dtype)throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");const f=a.shape.length,d=i.shape.length,u=p?a.shape[f-2]:a.shape[f-1],h=l?i.shape[d-1]:i.shape[d-2],v=p?a.shape[f-1]:a.shape[f-2],g=l?i.shape[d-2]:i.shape[d-1],b=a.shape.slice(0,-2),y=i.shape.slice(0,-2),S=o.ZSL.sizeFromShape(b),A=o.ZSL.sizeFromShape(y),k=o.ZEY.assertAndGetBroadcastShape(a.shape.slice(0,-2),i.shape.slice(0,-2)).concat([v,g]);o.ZSL.assert(u===h,()=>`Error in matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${a.shape} and ${i.shape} and transposeA=${p} and transposeB=${l} must match.`);const z=l?[A,g,h]:[A,h,g],H=ue({inputs:{x:a},backend:s,attrs:{shape:p?[S,u,v]:[S,v,u]}}),G=ue({inputs:{x:i},backend:s,attrs:{shape:z}}),X=s.dataIdMap.get(H.dataId).id,K=s.dataIdMap.get(G.dataId).id,U=p?H.shape[2]:H.shape[1],ne=l?G.shape[1]:G.shape[2],ae=Math.max(S,A),he=s.makeOutput([ae,U,ne],H.dtype),Xe=s.dataIdMap.get(he.dataId).id,Ft=new Uint8Array(new Int32Array(H.shape).buffer),Nt=new Uint8Array(new Int32Array(G.shape).buffer);return Ve(X,Ft,H.shape.length,K,Nt,G.shape.length,p,l,Xe),s.disposeData(H.dataId),s.disposeData(G.dataId),he.shape=k,he}};var Fe=Y(63685);function Ne(r){const{inputs:{x:n},attrs:{begin:s,size:c},backend:a}=r,[i,p]=o.Kro.parseSliceParams(n,s,c),l=o.Kro.isSliceContinous(n.shape,i,p),f=a.readSync(n.dataId),d=a.makeOutput(p,n.dtype),u=o.ZSL.computeStrides(n.shape),h=a.dataIdMap.get(d.dataId);if(l){const b=o.Kro.computeFlatOffset(i,u);return"string"===n.dtype?h.stringBytes=f.slice(b,b+o.ZSL.sizeFromShape(p)):a.typedArrayFromHeap(d).set(f.subarray(b,b+o.ZSL.sizeFromShape(p))),d}if("string"===n.dtype){const b=(0,Fe.HS)(f,i,p,n.shape,n.dtype);return h.stringBytes=b,d}const v=a.typedArrayFromHeap(d),g=n.shape.length;if(2===g)!function Ge(r,n,s,c,a){let i=0;const p=c[0],l=c[1],f=p+a[0];for(let d=p;d<f;d++){const u=d*n+l;s.set(r.subarray(u,u+a[1]),i),i+=a[1]}}(f,u[0],v,i,p);else if(3===g)!function Qe(r,n,s,c,a,i){let p=0;const l=a[0],f=a[1],d=a[2],u=l+i[0],h=f+i[1];for(let v=l;v<u;v++)for(let g=f;g<h;g++){const b=v*n+g*s+d;c.set(r.subarray(b,b+i[2]),p),p+=i[2]}}(f,u[0],u[1],v,i,p);else if(4===g)!function le(r,n,s,c,a,i,p){let l=0;const f=i[0],d=i[1],u=i[2],h=f+p[0],v=d+p[1],g=u+p[2],b=i[3];for(let y=f;y<h;y++)for(let S=d;S<v;S++)for(let A=u;A<g;A++){const w=y*n+S*s+A*c+b;a.set(r.subarray(w,w+p[3]),l),l+=p[3]}}(f,u[0],u[1],u[2],v,i,p);else{const b=(0,Fe.HS)(f,i,p,n.shape,n.dtype);v.set(b)}return d}const Qt={kernelName:o.JiE,backendName:"wasm",kernelFunc:Ne},Jn={kernelName:o.Ik2,backendName:"wasm",kernelFunc:function Kn(r){const{inputs:n,backend:s,attrs:c}=r,{x:a}=n,{blockShape:i,crops:p}=c,l=i.reduce((A,w)=>A*w),f=o.C0T.getReshaped(a.shape,i,l),d=o.C0T.getPermuted(f.length,i.length),u=o.C0T.getReshapedPermuted(a.shape,i,l),h=o.C0T.getSliceBeginCoords(p,i.length),v=o.C0T.getSliceSize(u,p,i.length),g=ue({inputs:{x:a},backend:s,attrs:{shape:f}}),b=J({inputs:{x:g},backend:s,attrs:{perm:d}}),y=ue({inputs:{x:b},backend:s,attrs:{shape:u}}),S=Ne({inputs:{x:y},backend:s,attrs:{begin:h,size:v}});return s.disposeData(g.dataId),s.disposeData(b.dataId),s.disposeData(y.dataId),S}};let Qn;const Re={kernelName:o.N4F,backendName:"wasm",setupFunc:function Ee(r){Qn=r.wasm.cwrap(o.N4F,null,["number","number","boolean","number","number","number"])},kernelFunc:function Ye(r){const{backend:n,inputs:s,attrs:c}=r,{x:a,weights:i}=s,{size:p}=c,l=0!==i.shape.reduce((h,v)=>h*v,1),d=n.makeOutput(1===a.shape.length?[p]:[a.shape[0],p],i.dtype);function u(h){return n.dataIdMap.get(h.dataId).id}return Qn(u(a),p,l,u(i),B[i.dtype],u(d)),d}},Yt=Z(o.HNs),Yn={kernelName:o.vj7,backendName:"wasm",kernelFunc:function Ue(r){const{inputs:n,backend:s}=r,{s0:c,s1:a}=n,i=s.typedArrayFromHeap(c),p=s.typedArrayFromHeap(a),l=o.C0T.assertAndGetBroadcastShape(Array.from(i),Array.from(p));return s.makeOutput([l.length],"int32",void 0,new Int32Array(l))}};function Se(r){const{inputs:{x:n},attrs:{dtype:s},backend:c}=r,a=c.makeOutput(n.shape,s),i=c.typedArrayFromHeap(n);return c.typedArrayFromHeap(a).set(i),a}const et={kernelName:o.KXH,backendName:"wasm",kernelFunc:Se},me=O(o.QDP);let mt;const rs={kernelName:o.vaV,backendName:"wasm",setupFunc:function ea(r){mt=r.wasm.cwrap(o.vaV,null,["number","number","number","number"])},kernelFunc:function ta(r){const{inputs:n,backend:s,attrs:c}=r,{x:a}=n,{clipValueMin:i,clipValueMax:p}=c,l=s.dataIdMap.get(a.dataId).id,f=s.makeOutput(a.shape,a.dtype),d=s.dataIdMap.get(f.dataId).id;return mt(l,i,p,d),f}};var ss=Y(91332);function ft(r){const{inputs:n,backend:s}=r,c=o.ZSL.parseAxisParam(r.attrs.axis,n[0].shape)[0],a=n.map(g=>g.shape);o.C0T.assertParamsConsistent(a,c);let i=o.C0T.computeOutShape(n.map(g=>g.shape),c);const p=n.filter(g=>o.ZSL.sizeFromShape(g.shape)>0);if(1===p.length)return Ie({inputs:{x:p[0]},backend:s});const l=s.makeOutput(i,n[0].dtype);if(0===o.ZSL.sizeFromShape(i))return l;if("string"===p[0].dtype){const g=p.map(k=>{const z=[-1,o.ZSL.sizeFromShape(k.shape.slice(c))];return ue({inputs:{x:k},backend:s,attrs:{shape:z}})}),b=g.map(k=>({vals:s.readSync(k.dataId),shape:k.shape}));i=o.C0T.computeOutShape(g.map(k=>k.shape),1);const S=(0,ss.h)(b,i,n[0].dtype,1===g[0].shape[0]),A=o.C0T.computeOutShape(p.map(k=>k.shape),c);return l.shape=A,s.dataIdMap.get(l.dataId).stringBytes=o.C0T.fromStringArrayToUint8(S),g.forEach(k=>s.disposeData(k.dataId)),l}const f=o.ZSL.sizeFromShape(p[0].shape.slice(0,c));let d=0;const u=p.map(g=>{const b=o.ZSL.sizeFromShape(g.shape.slice(c));return d+=b,b}),h=p.map(g=>s.typedArrayFromHeap(g)),v=s.typedArrayFromHeap(l);for(let g=0;g<f;g++){let b=g*d;for(let y=0;y<h.length;y++){const S=u[y],A=g*S,w=h[y].subarray(A,A+S);v.set(w,b),b+=S}}return l}const je={kernelName:o.$dB,backendName:"wasm",kernelFunc:ft};let en;const aa={kernelName:o.p2J,backendName:"wasm",setupFunc:function na(r){en=r.wasm.cwrap(o.p2J,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function ht(r){const{inputs:n,attrs:s,backend:c}=r,{x:a,filter:i}=n,p=c.dataIdMap.get(a.dataId).id,l=c.dataIdMap.get(i.dataId).id,{strides:f,dilations:d,pad:u,dimRoundingMode:h,dataFormat:v}=s,g=o.C0T.convertConv2DDataFormat(v),b=o.C0T.computeConv2DInfo(a.shape,i.shape,f,d,u,h,!1,g),y=b.filterHeight,S=b.filterWidth,A=b.padInfo.top,w=b.padInfo.right,k=b.padInfo.bottom,C=b.padInfo.left,z=b.dilationHeight,H=b.dilationWidth,G=b.strideHeight,X=b.strideWidth,K=b.inChannels,U=b.outChannels,ne="SAME"===b.padInfo.type?1:0;if("channelsLast"!==b.dataFormat)throw new Error(`wasm backend Conv2D does not support dataFormat:'${b.dataFormat}'. Please use 'channelsLast'.`);const ae=c.makeOutput(b.outShape,"float32"),he=c.dataIdMap.get(ae.dataId).id;return en(p,a.shape[0],a.shape[1],a.shape[2],l,y,S,A,w,k,C,ne,z,H,G,X,K,U,he),ae}};let gt;const nn={kernelName:o.jfg,backendName:"wasm",setupFunc:function tn(r){gt=r.wasm.cwrap(o.jfg,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function ra(r){const{backend:n,inputs:s,attrs:c}=r,{dy:a,filter:i}=s,{strides:p,pad:l,dataFormat:f,dimRoundingMode:d,inputShape:u}=c,v=o.C0T.convertConv2DDataFormat(f),g=o.C0T.computeConv2DInfo(u,i.shape,p,1,l,d,!1,v),{batchSize:b,filterHeight:y,filterWidth:S,inChannels:A,inHeight:w,inWidth:k,outChannels:C,outHeight:z,outWidth:H,strideHeight:G,strideWidth:X}=g,K=y-1-g.padInfo.top,U=S-1-g.padInfo.left,ne="channelsLast"===g.dataFormat,ae=o.ZSL.computeStrides(g.inShape),he=o.ZSL.computeStrides(a.shape),[Xe,Ft,Nt]=o.ZSL.computeStrides(i.shape),Kr=ae[0],Jr=ne?ae[1]:ae[2],Qr=ne?ae[2]:1,Rt=ne?1:ae[1],Yr=he[0],es=ne?he[1]:he[2],we=ne?he[2]:1,Li=ne?1:he[1],Eo=n.makeOutput(g.inShape,"float32"),Wi=n.dataIdMap.get(Eo.dataId).id,Hi=n.dataIdMap.get(a.dataId).id,zi=n.dataIdMap.get(i.dataId).id;return gt(Hi,zi,b,y,S,w,k,A,z,H,C,G,X,K,U,Xe,Ft,Nt,Kr,Jr,Qr,Rt,Yr,es,we,Li,Wi),Eo}};let an;const sa={kernelName:o.A1h,backendName:"wasm",setupFunc:function T(r){an=r.wasm.cwrap(o.A1h,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function _t(r){const{inputs:n,backend:s,attrs:c}=r,{x:a,filter:i}=n,{strides:p,pad:l,dilations:f}=c;if("float32"!==a.dtype)throw new Error(`Tensor x must have dtype float32, got ${a.dtype}`);if("float32"!==i.dtype)throw new Error(`Tensor filter must have dtype float32, got ${i.dtype}`);const d=o.C0T.computeConv3DInfo(a.shape,i.shape,p,f,l),u=s.makeOutput(d.outShape,a.dtype);return an(s.dataIdMap.get(a.dataId).id,s.dataIdMap.get(i.dataId).id,s.dataIdMap.get(u.dataId).id,d.batchSize,d.inDepth,d.inHeight,d.inWidth,d.inChannels,d.outDepth,d.outHeight,d.outWidth,d.outChannels,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.filterDepth,d.filterHeight,d.filterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),u}};let bt;const ua={kernelName:o.iGz,backendName:"wasm",setupFunc:function tt(r){bt=r.wasm.cwrap(o.iGz,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function oa(r){const{inputs:n,backend:s,attrs:c}=r,{x:a,dy:i}=n,{strides:p,pad:l,filterShape:f}=c;if("float32"!==a.dtype)throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if("float32"!==i.dtype)throw new Error(`Tensor filter must have dtype float32, got ${i.dtype}`);const d=o.C0T.computeConv3DInfo(a.shape,f,p,1,l),u=s.makeOutput(d.filterShape,i.dtype);return bt(s.dataIdMap.get(a.dataId).id,s.dataIdMap.get(i.dataId).id,s.dataIdMap.get(u.dataId).id,d.batchSize,d.inDepth,d.inHeight,d.inWidth,d.inChannels,d.outDepth,d.outHeight,d.outWidth,d.outChannels,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.filterDepth,d.filterHeight,d.filterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),u}};let rn;const sn={kernelName:o.gC7,backendName:"wasm",setupFunc:function ia(r){rn=r.wasm.cwrap(o.gC7,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function da(r){const{inputs:n,backend:s,attrs:c}=r,{dy:a,filter:i}=n,{pad:p,strides:l,inputShape:f}=c;if("float32"!==a.dtype)throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if("float32"!==i.dtype)throw new Error(`Tensor filter must have dtype float32, got ${i.dtype}`);const d=o.C0T.computeConv3DInfo(f,i.shape,l,1,p),u=s.makeOutput(d.inShape,a.dtype);return rn(s.dataIdMap.get(i.dataId).id,s.dataIdMap.get(a.dataId).id,s.dataIdMap.get(u.dataId).id,d.batchSize,d.inDepth,d.inHeight,d.inWidth,d.inChannels,d.outDepth,d.outHeight,d.outWidth,d.outChannels,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.filterDepth,d.filterHeight,d.filterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),u}},on=O(o.Mn0),ca=O(o.MnK);var un=function(r){return r[r.bilinear=0]="bilinear",r[r.nearest=1]="nearest",r}(un||{});let dn;const la={kernelName:o.MRQ,backendName:"wasm",setupFunc:function yt(r){dn=r.wasm.cwrap(o.MRQ,null,["number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function pa(r){const{backend:n,inputs:s,attrs:c}=r,{method:a,extrapolationValue:i,cropSize:p}=c,{image:l,boxes:f,boxInd:d}=s,u=f.shape[0],[h,v]=p,g=[u,h,v,l.shape[3]];let y,b=n.dataIdMap.get(l.dataId);"float32"!==l.dtype&&(y=Se({backend:n,inputs:{x:l},attrs:{dtype:"float32"}}),b=n.dataIdMap.get(y.dataId));const S=b.id,A=n.dataIdMap.get(f.dataId).id,w=n.dataIdMap.get(d.dataId).id,k=n.makeOutput(g,"float32"),C=n.dataIdMap.get(k.dataId).id,z=new Uint8Array(new Int32Array(l.shape).buffer);return dn(S,A,w,u,z,h,v,un[a],i,C),null!=y&&n.disposeData(y.dataId),k}};let cn;const fa={kernelName:o.jj_,backendName:"wasm",setupFunc:function Ze(r){cn=r.wasm.cwrap(o.jj_,null,["number","number","number","number","number","number"])},kernelFunc:function ma(r){const{inputs:n,backend:s,attrs:c}=r,{x:a}=n,{axis:i,exclusive:p,reverse:l}=c,f=a.shape.length;o.ZSL.assert("float32"===a.dtype||"int32"===a.dtype,()=>`cumprod does not support ${a.dtype} tensors in the WASM backend`);const d=o.C0T.getAxesPermutation([i],f);let u=a;null!==d&&(u=J({inputs:{x:a},attrs:{perm:d},backend:s}));const h=o.C0T.getInnerMostAxes(1,f)[0];o.C0T.assertAxesAreInnerMostDims("cumprod",[h],f);const v=s.makeOutput(u.shape,u.dtype),g=u.shape[h],b=s.dataIdMap.get(u.dataId).id,y=s.dataIdMap.get(v.dataId).id;cn(b,p?1:0,l?1:0,g,y,B[a.dtype]);let S=v;return null!==d&&(S=J({inputs:{x:v},attrs:{perm:o.C0T.getUndoAxesPermutation(d)},backend:s}),s.disposeData(u.dataId),s.disposeData(v.dataId)),S}};let It;const ga={kernelName:o.nY8,backendName:"wasm",setupFunc:function ha(r){It=r.wasm.cwrap(o.nY8,null,["number","number","number","number","number","number"])},kernelFunc:function vt(r){const{inputs:n,backend:s,attrs:c}=r,{x:a}=n,{axis:i,exclusive:p,reverse:l}=c,f=a.shape.length;o.ZSL.assert("float32"===a.dtype||"int32"===a.dtype,()=>`cumsum does not support ${a.dtype} tensors in the WASM backend`);const d=o.C0T.getAxesPermutation([i],f);let u=a;null!==d&&(u=J({inputs:{x:a},attrs:{perm:d},backend:s}));const h=o.C0T.getInnerMostAxes(1,f)[0];o.C0T.assertAxesAreInnerMostDims("cumsum",[h],f);const v=s.makeOutput(u.shape,u.dtype),g=u.shape[h],b=s.dataIdMap.get(u.dataId).id,y=s.dataIdMap.get(v.dataId).id;It(b,p?1:0,l?1:0,g,y,B[a.dtype]);let S=v;return null!==d&&(S=J({inputs:{x:v},attrs:{perm:o.C0T.getUndoAxesPermutation(d)},backend:s}),s.disposeData(u.dataId),s.disposeData(v.dataId)),S}};let pn;const St={kernelName:o.wNW,backendName:"wasm",setupFunc:function _a(r){pn=r.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])},kernelFunc:function Be(r){const{backend:n,inputs:s,attrs:c}=r,{x:a,weights:i}=s,{size:p,binaryOutput:l}=c,f=0!==i.shape.reduce((v,g)=>v*g,1),u=n.makeOutput(1===a.shape.length?[p]:[a.shape[0],p],i.dtype);function h(v){return n.dataIdMap.get(v.dataId).id}return pn(h(a),new Uint8Array(new Int32Array(a.shape).buffer),a.shape.length,p,f,h(i),B[i.dtype],l,h(u)),u}};let ln;const Ia={kernelName:o.TMz,backendName:"wasm",setupFunc:function ba(r){ln=r.wasm.cwrap(o.TMz,null,["number","number","number","array","number","array","array","number","number"])},kernelFunc:function ya(r){const{backend:n,inputs:s,attrs:c}=r,{x:a}=s,{blockSize:i,dataFormat:p}=c,l=a.shape[0],h=("NHWC"===p?a.shape[1]:a.shape[2])*i,v=("NHWC"===p?a.shape[2]:a.shape[3])*i,g=("NHWC"===p?a.shape[3]:a.shape[1])/(i*i),b="NHWC"===p?[l,h,v,g]:[l,g,h,v],y=n.makeOutput(b,"float32"),A=n.dataIdMap.get(a.dataId).id,w=new Uint8Array(new Int32Array(o.ZSL.computeStrides(a.shape)).buffer),k=new Uint8Array(new Int32Array(b).buffer),C=new Uint8Array(new Int32Array(o.ZSL.computeStrides(b)).buffer),z=n.dataIdMap.get(y.dataId).id;return ln(A,i,"NHWC"===p?1:0,w,a.shape.length-1,k,C,b.length,z),y}};let wt;const Sa={kernelName:o.tGH,backendName:"wasm",setupFunc:function mn(r){wt=r.wasm.cwrap(o.tGH,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function va(r){const{inputs:n,attrs:s,backend:c}=r,{x:a,filter:i}=n,p=c.dataIdMap.get(a.dataId).id,l=c.dataIdMap.get(i.dataId).id,{strides:f,dilations:d,pad:u,dimRoundingMode:h}=s,g=o.C0T.computeConv2DInfo(a.shape,i.shape,f,null==d?[1,1]:d,u,h,!0),b=g.filterHeight,y=g.filterWidth,S=g.padInfo.top,A=g.padInfo.right,w=g.padInfo.bottom,k=g.padInfo.left,C=g.dilationHeight,z=g.dilationWidth,H=g.strideHeight,G=g.strideWidth,X=g.inChannels,K=g.outChannels,U="SAME"===g.padInfo.type?1:0;if("channelsLast"!==g.dataFormat)throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${g.dataFormat}'. Please use 'channelsLast'.`);const ne=c.makeOutput(g.outShape,"float32"),ae=c.dataIdMap.get(ne.dataId).id;return wt(p,a.shape[0],a.shape[1],a.shape[2],l,b,y,S,A,w,k,U,C,z,H,G,X,K,ae),ne}};let kt;const ka={kernelName:o.ORI,backendName:"wasm",setupFunc:function fn(r){kt=r.wasm.cwrap("Diag",null,["number","number","number","number"])},kernelFunc:function wa(r){const{inputs:n,backend:s}=r,{x:c}=n,a=o.ZSL.sizeFromShape(c.shape),i=s.makeOutput([...c.shape,...c.shape],c.dtype);return kt(s.dataIdMap.get(c.dataId).id,B[c.dtype],a,s.dataIdMap.get(i.dataId).id),i}};let hn;const os={kernelName:o.jxD,backendName:"wasm",setupFunc:function Ma(r){hn=r.wasm.cwrap(o.jxD,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function gn(r){const{inputs:n,backend:s,attrs:c}=r,{x:a,filter:i}=n,{strides:p,pad:l,dilations:f}=c;if(a.dtype!==i.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${a.dtype} and ${i.dtype}`);const d=o.C0T.computeDilation2DInfo(a.shape,i.shape,p,l,"NHWC",f),u=s.makeOutput(d.outShape,a.dtype);return hn(s.dataIdMap.get(a.dataId).id,s.dataIdMap.get(i.dataId).id,s.dataIdMap.get(u.dataId).id,B[a.dtype],d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.filterHeight,d.filterWidth,d.padInfo.top,d.padInfo.left),u}};let _n;const Da={kernelName:o.pk0,backendName:"wasm",setupFunc:function Aa(r){_n=r.wasm.cwrap(o.pk0,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function xa(r){const{inputs:n,backend:s,attrs:c}=r,{x:a,filter:i,dy:p}=n,{strides:l,pad:f,dilations:d}=c;if(a.dtype!==i.dtype||a.dtype!==p.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${i.dtype}, and ${p.dtype}`);const u=o.C0T.computeDilation2DInfo(a.shape,i.shape,l,f,"NHWC",d),h=s.makeOutput(i.shape,i.dtype);return _n(s.dataIdMap.get(a.dataId).id,s.dataIdMap.get(i.dataId).id,s.dataIdMap.get(p.dataId).id,s.dataIdMap.get(h.dataId).id,B[a.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),h}};let bn;const Na={kernelName:o.bP9,backendName:"wasm",setupFunc:function Ca(r){bn=r.wasm.cwrap(o.bP9,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function Fa(r){const{inputs:n,backend:s,attrs:c}=r,{x:a,filter:i,dy:p}=n,{strides:l,pad:f,dilations:d}=c;if(a.dtype!==i.dtype||a.dtype!==p.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${i.dtype}, and ${p.dtype}`);const u=o.C0T.computeDilation2DInfo(a.shape,i.shape,l,f,"NHWC",d),h=s.makeOutput(a.shape,a.dtype);return bn(s.dataIdMap.get(a.dataId).id,s.dataIdMap.get(i.dataId).id,s.dataIdMap.get(p.dataId).id,s.dataIdMap.get(h.dataId).id,B[a.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),h}},Ra=O(o.Pah);let yn;const Ea={kernelName:o.rsH,backendName:"wasm",setupFunc:function Ta(r){yn=r.wasm.cwrap(o.rsH,null,["number","number","number"])},kernelFunc:function Pa(r){const{inputs:n,backend:s}=r,{dy:c,y:a}=n,i=s.makeOutput(a.shape,"float32"),p=l=>s.dataIdMap.get(l.dataId).id;return yn(p(a),p(c),p(i)),i}},Ba=Z(o.BRl,0,"bool"),Oa=O(o._s9),La=O(o.ox3,"float32");function Mt(r){const{inputs:n,attrs:s,backend:c}=r,{input:a}=n,{dim:i}=s,p=a.shape.length,l=a.shape.slice();let f=i;return i<0&&(o.ZSL.assert(-(p+1)<=i,()=>`Axis must be in the interval [${-(p+1)}, ${p}]`),f=p+i+1),l.splice(f,0,1),ue({inputs:{x:a},backend:c,attrs:{shape:l}})}const Wa={kernelName:o.ybN,backendName:"wasm",kernelFunc:Mt},Ha=O(o.ybj,"float32");function In(r){const{attrs:{shape:n,value:s},backend:c}=r;let{attrs:{dtype:a}}=r;a=a||o.ZSL.inferDtype(s);const i=c.makeOutput(n,a);return c.typedArrayFromHeap(i).fill(s),i}const za={kernelName:o.SQl,backendName:"wasm",kernelFunc:In};let vn;const Ua={kernelName:o.BxF,backendName:"wasm",kernelFunc:function Ga(r){const{inputs:n,backend:s}=r,{image:c}=n,a=s.makeOutput(c.shape,c.dtype),i=s.dataIdMap.get(c.dataId).id,p=s.dataIdMap.get(a.dataId).id,[l,f,d,u]=c.shape;return vn(i,l,f,d,u,p),a},setupFunc:function Va(r){vn=r.wasm.cwrap(o.BxF,null,["number","number","number","number","number","number"])}},ja=O(o.ZgB),Za=Z(o.ElG);let Sn;const Xa={kernelName:o.i5R,backendName:"wasm",setupFunc:function qa(r){Sn=r.wasm.cwrap(o.i5R,null,["number","number","number","number","number","number","number"])},kernelFunc:function $a(r){const{backend:n,inputs:s,attrs:c}=r,{varianceEpsilon:a}=c,{x:i,mean:p,variance:l,offset:f,scale:d}=s,u=n.dataIdMap.get(i.dataId).id,h=n.dataIdMap.get(p.dataId).id,v=n.dataIdMap.get(l.dataId).id,g=null!=f?n.dataIdMap.get(f.dataId).id:0,b=null!=d?n.dataIdMap.get(d.dataId).id:0,y=n.makeOutput(i.shape,i.dtype);if(0===o.ZSL.sizeFromShape(i.shape))return y;const S=n.dataIdMap.get(y.dataId).id;return Sn(u,h,v,g,b,a,S),y}};let wn;const Qa={kernelName:o.aAr,backendName:"wasm",setupFunc:function Ka(r){wn=r.wasm.cwrap(o.aAr,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function Ja(r){const{inputs:n,attrs:s,backend:c}=r,{x:a,filter:i,bias:p,preluActivationWeights:l}=n,{strides:f,pad:d,dilations:u,dataFormat:h,dimRoundingMode:v,activation:g,leakyreluAlpha:b}=s,y=o.C0T.computeConv2DInfo(a.shape,i.shape,f,u,d,v),S=re[g];if(null==S)throw new Error(`${g} activation not yet supported for FusedConv2D in the wasm backend.`);const A=c.dataIdMap.get(a.dataId).id,w=c.dataIdMap.get(i.dataId).id,k=y.outChannels;let C=0;if(null!=p){const we=c.dataIdMap.get(p.dataId);if(1!==we.shape.length)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${we.shape.length}.`);if(we.shape[0]!==k)throw new Error(`FusedConv2D bias shape (${we.shape}) does not match the number of output channels (${k})`);C=we.id}const z=y.filterHeight,H=y.filterWidth,G=y.padInfo.top,X=y.padInfo.right,K=y.padInfo.bottom,U=y.padInfo.left,ne=y.dilationHeight,ae=y.dilationWidth,he=y.strideHeight,Xe=y.strideWidth,Ft=y.inChannels,Nt="SAME"===y.padInfo.type?1:0,Kr=y.batchSize,Jr=y.inHeight,Qr=y.inWidth;if("NHWC"!==h)throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${h}'. Please use 'NHWC'.`);const Rt=c.makeOutput(y.outShape,"float32"),Yr=c.dataIdMap.get(Rt.dataId).id,es=null==l?0:c.dataIdMap.get(l.dataId).id;return wn(A,Kr,Jr,Qr,w,z,H,C,G,X,K,U,Nt,ne,ae,he,Xe,Ft,k,S,es,b||0,Yr),Rt}};let kn;const tr={kernelName:o.T7M,backendName:"wasm",setupFunc:function Ya(r){kn=r.wasm.cwrap(o.T7M,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function er(r){const{inputs:n,attrs:s,backend:c}=r,{x:a,filter:i,bias:p,preluActivationWeights:l}=n,{strides:f,pad:d,dilations:u,dataFormat:h,dimRoundingMode:v,activation:g,leakyreluAlpha:b}=s,y=o.C0T.computeConv2DInfo(a.shape,i.shape,f,u,d,v,!0),S=re[g];if(null==S)throw new Error(`${g} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);const A=c.dataIdMap.get(a.dataId).id,w=c.dataIdMap.get(i.dataId).id,k=y.outChannels;let C=0;if(null!=p){const we=c.dataIdMap.get(p.dataId);if(1!==we.shape.length)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${we.shape.length}.`);if(we.shape[0]!==k)throw new Error(`FusedDepthwiseConv2D bias shape (${we.shape}) does not match the number of output channels (${k})`);C=we.id}const z=y.filterHeight,H=y.filterWidth,G=y.padInfo.top,X=y.padInfo.right,K=y.padInfo.bottom,U=y.padInfo.left,ne=y.dilationHeight,ae=y.dilationWidth,he=y.strideHeight,Xe=y.strideWidth,Ft=y.inChannels,Nt="SAME"===y.padInfo.type?1:0,Kr=y.batchSize,Jr=y.inHeight,Qr=y.inWidth;if("NHWC"!==h)throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${h}'. Please use 'NHWC'.`);const Rt=c.makeOutput(y.outShape,"float32"),Yr=c.dataIdMap.get(Rt.dataId).id,es=null==l?0:c.dataIdMap.get(l.dataId).id;return kn(A,Kr,Jr,Qr,w,z,H,C,G,X,K,U,Nt,ne,ae,he,Xe,Ft,k,S,es,b||0,Yr),Rt}};let Mn;const rr={kernelName:o.O4G,backendName:"wasm",setupFunc:function nr(r){Mn=r.wasm.cwrap(o.O4G,null,["number","number","number","number","number","number","array","number"])},kernelFunc:function ar(r){const{backend:n,inputs:s}=r,{params:c,indices:a}=s,[i,p,l,f]=o.FJy.prepareAndValidate(c,a),d=n.makeOutput(i,c.dtype);if(0===p)return d;const u=a.shape,h=u[u.length-1],g=n.dataIdMap.get(c.dataId).id,y=n.dataIdMap.get(a.dataId).id,S=new Uint8Array(new Int32Array(f).buffer),A=n.dataIdMap.get(d.dataId).id;return Mn(g,B[c.dtype],y,p,h,l,S,A),d}};let An;const ur={kernelName:o.mxL,backendName:"wasm",setupFunc:function sr(r){An=r.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])},kernelFunc:function or(r){const{backend:n,inputs:s,attrs:c}=r,{x:a,indices:i}=s,{axis:p,batchDims:l}=c,f=o.ZSL.parseAxisParam(p,a.shape)[0],d=n.readSync(i.dataId),u=a.shape[f];for(let K=0;K<d.length;++K){const U=d[K];o.ZSL.assert(U<=u-1&&U>=0,()=>`GatherV2: the index value ${U} is not in [0, ${u-1}]`)}const h=o.C0T.segment_util.collectGatherOpShapeInfo(a,i,f,l),v=ue({inputs:{x:a},attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]},backend:n}),g=o.ZSL.sizeFromShape(i.shape),b=ue({inputs:{x:i},attrs:{shape:[h.batchSize,g/h.batchSize]},backend:n}),y=[h.batchSize,h.outerSize,g/h.batchSize,h.sliceSize],S=n.makeOutput(y,a.dtype);if(0===o.ZSL.sizeFromShape(a.shape))return S;const A=v.shape.length-1,k=n.dataIdMap.get(v.dataId).id,z=n.dataIdMap.get(b.dataId).id,H=n.dataIdMap.get(S.dataId).id,G=new Uint8Array(new Int32Array(o.ZSL.computeStrides(v.shape)).buffer),X=new Uint8Array(new Int32Array(o.ZSL.computeStrides(y)).buffer);return An(k,B[a.dtype],G,A,z,h.batchSize,X,H),n.disposeData(v.dataId),n.disposeData(b.dataId),S.shape=h.outputShape,S}},ir=Z(o.XhZ,0,"bool"),dr=Z(o.lLS,0,"bool"),cr=O(o.gIW,"bool"),pr=O(o.E3$,"bool"),lr=O(o.iPs,"bool");let xn;const hr={kernelName:o.X0$,backendName:"wasm",setupFunc:function mr(r){xn=r.wasm.cwrap(o.X0$,null,["number","number","number","number"])},kernelFunc:function fr(r){const{inputs:{x:n},attrs:{alpha:s},backend:c}=r,a=c.dataIdMap.get(n.dataId).id,i=c.makeOutput(n.shape,"float32");if(0!==o.ZSL.sizeFromShape(n.shape)){const p=c.dataIdMap.get(i.dataId).id;xn(a,B[n.dtype],s,p)}return i}},gr=Z(o.mIA,0,"bool"),_r=Z(o.CwD,0,"bool");let Dn;const Ir={kernelName:o.mnI,backendName:"wasm",setupFunc:function br(r){Dn=r.wasm.cwrap(o.mnI,null,["number","number","number","number"])},kernelFunc:function yr(r){const{attrs:n,backend:s}=r,{start:c,stop:a,num:i}=n,p=Math.floor(i),l=s.makeOutput([p],"float32");return Dn(s.dataIdMap.get(l.dataId).id,c,a,p),l}},vr=O(o.tG8),Sr=O(o.Cg$),wr=Z(o.RUm,0,"bool"),kr=O(o.nZd),Mr=Z(o.LXA,0,"bool"),Ar=Z(o.RW8,0,"bool");let Cn;const Cr={kernelName:o.jM4,backendName:"wasm",setupFunc:function xr(r){Cn=r.wasm.cwrap(o.jM4,null,["number","number","number","number","number","number","number"])},kernelFunc:function Dr(r){const{inputs:n,backend:s,attrs:c}=r,{x:a}=n,{depthRadius:i,bias:p,alpha:l,beta:f}=c;if("float32"!==a.dtype)throw new Error("LRN error: x must have dtype float32");const d=s.makeOutput(a.shape,a.dtype);return Cn(s.dataIdMap.get(a.dataId).id,s.dataIdMap.get(d.dataId).id,a.shape[3],i,p,l,f),d}};let Fn;const Rr={kernelName:o.ToN,backendName:"wasm",setupFunc:function Fr(r){Fn=r.wasm.cwrap(o.ToN,null,["number","number","number","number","number","number","number","number","number"])},kernelFunc:function Nr(r){const{inputs:n,backend:s,attrs:c}=r,{x:a,y:i,dy:p}=n,{depthRadius:l,bias:f,alpha:d,beta:u}=c;if("float32"!==a.dtype||"float32"!==i.dtype||"float32"!==p.dtype)throw new Error("LRNGrad error: x, y, and dy must have dtype float32");const h=s.makeOutput(a.shape,a.dtype);return Fn(s.dataIdMap.get(a.dataId).id,s.dataIdMap.get(i.dataId).id,s.dataIdMap.get(p.dataId).id,s.dataIdMap.get(h.dataId).id,p.shape[3],l,f,d,u),h}};let Nn;const Er={kernelName:o.VAI,backendName:"wasm",setupFunc:function Tr(r){Nn=r.wasm.cwrap(o.VAI,null,["number","number","number","number"])},kernelFunc:function Pr(r){const{backend:n,inputs:s,attrs:c}=r,{reductionIndices:a,keepDims:i}=c,{x:p}=s;let f=n.dataIdMap.get(p.dataId).id,d=p;const{transposed:u,axes:h,originalAxes:v,inputWasTransposed:g}=ce(p,a,n);g&&(d=u,f=n.dataIdMap.get(u.dataId).id),o.C0T.assertAxesAreInnerMostDims("max",h,d.shape.length);const[y,S]=o.C0T.computeOutAndReduceShapes(d.shape,h),A=o.ZSL.sizeFromShape(S),w=n.makeOutput(y,p.dtype);if(0!==o.ZSL.sizeFromShape(d.shape)){const k=n.dataIdMap.get(w.dataId).id;Nn(f,B[p.dtype],A,k)}if(g&&n.disposeData(u.dataId),i){const k=o.C0T.expandShapeToKeepDim(w.shape,v);w.shape=k}return w}},Br=Z(o.LDN);let Rn;const Wr={kernelName:o.t3d,backendName:"wasm",setupFunc:function Or(r){Rn=r.wasm.cwrap(o.t3d,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function Lr(r){const{inputs:n,attrs:s,backend:c}=r,a=n.x,i=c.dataIdMap.get(a.dataId).id;o.ZSL.assert("float32"===a.dtype,()=>`Error in MaxPool: only float32 input is supported. Got ${a.dtype}.`);const{filterSize:p,strides:l,pad:f,dimRoundingMode:d}=s,u=o.C0T.computePool2DInfo(a.shape,p,l,1,f,d),h=u.filterHeight,v=u.filterWidth,g=u.padInfo.top,b=u.padInfo.right,y=u.padInfo.bottom,S=u.padInfo.left,A=u.dilationHeight,w=u.dilationWidth,k=u.strideHeight,C=u.strideWidth,z=u.inChannels,H=u.outChannels;if("channelsLast"!==u.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${u.dataFormat}'. Please use 'channelsLast'.`);const G=c.makeOutput(u.outShape,"float32"),X=c.dataIdMap.get(G.dataId).id;return Rn(i,a.shape[0],a.shape[1],a.shape[2],h,v,g,b,y,S,A,w,k,C,z,H,X),G}};let At;const Hr={kernelName:o.ySp,backendName:"wasm",setupFunc:function Tn(r){At=r.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function xt(r){const{inputs:n,backend:s,attrs:c}=r,{x:a}=n,{filterSize:i,strides:p,pad:l,dimRoundingMode:f,dataFormat:d}=c,u=o.C0T.computePool3DInfo(a.shape,i,p,1,l,f,d),h=s.makeOutput(u.outShape,a.dtype);return At(s.dataIdMap.get(a.dataId).id,s.dataIdMap.get(h.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),h}};let Pn;const at={kernelName:o.cHb,backendName:"wasm",setupFunc:function nt(r){Pn=r.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function En(r){const{inputs:n,backend:s,attrs:c}=r,{dy:a,input:i}=n,{filterSize:p,strides:l,pad:f,dimRoundingMode:d}=c,u=o.C0T.computePool3DInfo(i.shape,p,l,1,f,d),h=s.makeOutput(i.shape,i.dtype);return Pn(s.dataIdMap.get(i.dataId).id,s.dataIdMap.get(a.dataId).id,s.dataIdMap.get(h.dataId).id,u.batchSize,u.inChannels,u.inDepth,u.inHeight,u.inWidth,u.outDepth,u.outHeight,u.outWidth,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.effectiveFilterDepth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),h}};let qe;const M={kernelName:o.RXX,backendName:"wasm",setupFunc:function zr(r){qe=r.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function I(r){const{inputs:n,backend:s,attrs:c}=r,{dy:a,input:i}=n,{filterSize:p,strides:l,pad:f,dimRoundingMode:d}=c,u=o.C0T.computePool2DInfo(i.shape,p,l,1,f,d),h=s.makeOutput(i.shape,i.dtype);return qe(s.dataIdMap.get(i.dataId).id,s.dataIdMap.get(a.dataId).id,s.dataIdMap.get(h.dataId).id,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left),h}};let N;const $={kernelName:o.TL8,backendName:"wasm",setupFunc:function V(r){N=r.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function q(r){const{inputs:n,backend:s,attrs:c}=r,{x:a}=n,{filterSize:i,strides:p,pad:l,includeBatchInIndex:f}=c;o.ZSL.assert(4===a.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`);const d=[1,1];o.ZSL.assert(o.C0T.eitherStridesOrDilationsAreOne(p,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${p} and dilations '${d}'`);const u=o.C0T.computePool2DInfo(a.shape,i,p,[1,1],l),h=s.makeOutput(u.outShape,a.dtype),v=s.makeOutput(u.outShape,"int32");return N(s.dataIdMap.get(a.dataId).id,s.dataIdMap.get(h.dataId).id,s.dataIdMap.get(v.dataId).id,B[a.dtype],f,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left),[h,v]}};let L;const _e={kernelName:o.g5A,backendName:"wasm",setupFunc:function W(r){L=r.wasm.cwrap(o.g5A,null,["number, number, number"])},kernelFunc:function te(r){const{backend:n,inputs:s,attrs:c}=r,{axis:a,keepDims:i}=c,{x:p}=s,l=n.dataIdMap.get(p.dataId).id;let f=l,d=p;const{transposed:u,axes:h,originalAxes:v,inputWasTransposed:g}=ce(p,a,n);let b=h;if(g){const C=n.dataIdMap.get(u.dataId).id;C!==l&&(d=u,f=C,b=o.C0T.getInnerMostAxes(b.length,d.shape.length))}o.C0T.assertAxesAreInnerMostDims("mean",b,d.shape.length);const[y,S]=o.C0T.computeOutAndReduceShapes(d.shape,b),A=o.ZSL.sizeFromShape(S);let w=d;"float32"!==d.dtype&&(w=Se({backend:n,inputs:{x:d},attrs:{dtype:"float32"}}),f=n.dataIdMap.get(w.dataId).id);const k=n.makeOutput(y,"float32");if(0!==o.ZSL.sizeFromShape(d.shape)){const C=n.dataIdMap.get(k.dataId).id;L(f,A,C)}if(g&&n.disposeData(u.dataId),i){const C=o.C0T.expandShapeToKeepDim(k.shape,v);k.shape=C}return"float32"!==d.dtype&&n.disposeData(w.dataId),k}};let Me;const Vr={kernelName:o.lNG,backendName:"wasm",setupFunc:function Bn(r){Me=r.wasm.cwrap(o.lNG,null,["number","number","number","number"])},kernelFunc:function Dt(r){const{backend:n,inputs:s,attrs:c}=r,{axis:a,keepDims:i}=c,{x:p}=s,l=n.dataIdMap.get(p.dataId).id;let f=l,d=p;const{transposed:u,axes:h,originalAxes:v,inputWasTransposed:g}=ce(p,a,n);if(g){const k=n.dataIdMap.get(u.dataId).id;k!==l&&(d=u,f=k)}o.C0T.assertAxesAreInnerMostDims("min",h,d.shape.length);const[y,S]=o.C0T.computeOutAndReduceShapes(d.shape,h),A=o.ZSL.sizeFromShape(S),w=n.makeOutput(y,d.dtype);if(0!==o.ZSL.sizeFromShape(d.shape)){const k=n.dataIdMap.get(w.dataId).id;Me(f,B[p.dtype],A,k)}if(g&&n.disposeData(u.dataId),i){const k=o.C0T.expandShapeToKeepDim(w.shape,v);w.shape=k}return w}},Oe=Z(o.LG0);var Ct=function(r){return r[r.reflect=0]="reflect",r[r.symmetric=1]="symmetric",r}(Ct||{});let _s;const Os={kernelName:o.x7F,backendName:"wasm",kernelFunc:function Bs(r){const{inputs:{x:n},backend:s,attrs:{paddings:c,mode:a}}=r,i=c.map((b,y)=>b[0]+n.shape[y]+b[1]),p=s.dataIdMap.get(n.dataId).id,l=s.makeOutput(i,n.dtype),f=s.dataIdMap.get(l.dataId).id,d=new Uint8Array(new Int32Array(n.shape).buffer),u=c.map(b=>b[0]),h=c.map(b=>b[1]),v=new Uint8Array(new Int32Array(u).buffer),g=new Uint8Array(new Int32Array(h).buffer);return _s(p,d,n.shape.length,B[n.dtype],v,g,Ct[a],f),l},setupFunc:function Es(r){_s=r.wasm.cwrap(o.x7F,null,["number","array","number","number","array","array","number","number"])}};let bs;function ys(r){const{backend:n,inputs:{logits:s},attrs:{dim:c}}=r,a=n.dataIdMap.get(s.dataId).id,i=n.makeOutput(s.shape,s.dtype),p=n.dataIdMap.get(i.dataId).id,l=s.shape[c],f=o.ZSL.sizeFromShape(s.shape)/l;return 0===o.ZSL.sizeFromShape(i.shape)||bs(a,p,l,f),i}const Ws={kernelName:o.rFG,backendName:"wasm",setupFunc:function Ls(r){bs=r.wasm.cwrap(o.rFG,null,["number","number","number","number"])},kernelFunc:ys};let Is;const Vs={kernelName:o.WT3,backendName:"wasm",setupFunc:function Hs(r){Is=r.wasm.cwrap(o.WT3,null,["number","number","number","number","number","number"])},kernelFunc:function zs(r){const{inputs:n,backend:s,attrs:c}=r,{logits:a}=n,{numSamples:i,seed:p,normalized:l}=c;if("float32"!==a.dtype)throw new Error(`Tensor logits must have dtype float32, got ${a.dtype}`);const f=l?a:ys({inputs:{logits:a},backend:s,attrs:{dim:a.shape.length-1}}),[d,u]=f.shape,h=s.makeOutput([d,i],"int32");return Is(s.dataIdMap.get(f.dataId).id,d,u,i,p,s.dataIdMap.get(h.dataId).id),l||s.disposeData(f.dataId),h}},Gs=Z(o.BLA),Us=Z(o.xu7),js=O(o.l0G);function Gr(r,n){const s=new Int32Array(r.wasm.HEAPU8.buffer,n,4),c=s[0],a=s[1],i=s[2],p=s[3];return r.wasm._free(n),{pSelectedIndices:c,selectedSize:a,pSelectedScores:i,pValidOutputs:p}}let vs;const $s={kernelName:o.SDM,backendName:"wasm",setupFunc:function Zs(r){vs=r.wasm.cwrap(o.SDM,"number",["number","number","number","number","number"])},kernelFunc:function qs(r){const{backend:n,inputs:s,attrs:c}=r,{iouThreshold:a,maxOutputSize:i,scoreThreshold:p}=c,{boxes:l,scores:f}=s,d=n.dataIdMap.get(l.dataId).id,u=n.dataIdMap.get(f.dataId).id,h=vs(d,u,i,a,p),{pSelectedIndices:v,selectedSize:g,pSelectedScores:b,pValidOutputs:y}=Gr(n,h);return n.wasm._free(b),n.wasm._free(y),n.makeOutput([g],"int32",v)}};let Ss;const On={kernelName:o.Zl4,backendName:"wasm",setupFunc:function Xs(r){Ss=r.wasm.cwrap(o.Zl4,"number",["number","number","number","number","number","bool"])},kernelFunc:function Ks(r){const{backend:n,inputs:s,attrs:c}=r,{iouThreshold:a,maxOutputSize:i,scoreThreshold:p,padToMaxOutputSize:l}=c,{boxes:f,scores:d}=s,u=n.dataIdMap.get(f.dataId).id,h=n.dataIdMap.get(d.dataId).id,v=Ss(u,h,i,a,p,l),{pSelectedIndices:g,selectedSize:b,pSelectedScores:y,pValidOutputs:S}=Gr(n,v);return n.wasm._free(y),[n.makeOutput([b],"int32",g),n.makeOutput([],"int32",S)]}};let ws;const Qs={kernelName:o.e0f,backendName:"wasm",setupFunc:function ks(r){ws=r.wasm.cwrap(o.e0f,"number",["number","number","number","number","number","number"])},kernelFunc:function Js(r){const{backend:n,inputs:s,attrs:c}=r,{iouThreshold:a,maxOutputSize:i,scoreThreshold:p,softNmsSigma:l}=c,{boxes:f,scores:d}=s,u=n.dataIdMap.get(f.dataId).id,h=n.dataIdMap.get(d.dataId).id,v=ws(u,h,i,a,p,l),{pSelectedIndices:g,selectedSize:b,pSelectedScores:y,pValidOutputs:S}=Gr(n,v);return n.wasm._free(S),[n.makeOutput([b],"int32",g),n.makeOutput([b],"float32",y)]}},Ms=Z(o.ylV,0,"bool");let As;const Ds={kernelName:o.urI,backendName:"wasm",setupFunc:function xs(r){As=r.wasm.cwrap(o.urI,null,["number","number","number","number","number"])},kernelFunc:function Ur(r){const{inputs:n,backend:s,attrs:c}=r,{indices:a}=n,{dtype:i,depth:p,onValue:l,offValue:f}=c,d=s.makeOutput([...a.shape,p],i),u=s.dataIdMap.get(d.dataId).id,v=s.dataIdMap.get(a.dataId).id;return As(v,p,l,f,u),d}},jr={kernelName:o.LWX,backendName:"wasm",kernelFunc:function Cs(r){const{inputs:{x:n},backend:s}=r,c=s.makeOutput(n.shape,n.dtype);return s.typedArrayFromHeap(c).fill(1),c}},Wn={kernelName:o.mM$,backendName:"wasm",kernelFunc:function Ln(r){const{inputs:n,backend:s,attrs:c}=r,{axis:a}=c;if(1===n.length)return Mt({inputs:{input:n[0]},backend:s,attrs:{dim:a}});const i=n[0].shape,p=n[0].dtype;n.forEach(u=>{o.ZSL.assertShapesMatch(i,u.shape,"All tensors passed to stack must have matching shapes"),o.ZSL.assert(p===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const l=[],d=ft({inputs:n.map(u=>{const h=Mt({inputs:{input:u},backend:s,attrs:{dim:a}});return l.push(h),h}),backend:s,attrs:{axis:a}});return l.forEach(u=>s.disposeData(u.dataId)),d}};let Fs;const Zr={kernelName:o.ODT,backendName:"wasm",kernelFunc:function Hn(r){const{inputs:{x:n},backend:s,attrs:{paddings:c,constantValue:a}}=r,i=c.map((y,S)=>y[0]+n.shape[S]+y[1]);if(0===o.ZSL.sizeFromShape(n.shape))return In({backend:s,attrs:{shape:i,value:a,dtype:n.dtype}});const p=s.dataIdMap.get(n.dataId).id,l=s.makeOutput(i,n.dtype),d=s.dataIdMap.get(l.dataId).id,u=new Uint8Array(new Int32Array(n.shape).buffer),h=c.map(y=>y[0]),v=c.map(y=>y[1]),g=new Uint8Array(new Int32Array(h).buffer),b=new Uint8Array(new Int32Array(v).buffer);return Fs(p,u,n.shape.length,B[n.dtype],g,b,a,d),l},setupFunc:function Ys(r){Fs=r.wasm.cwrap(o.ODT,null,["number","array","number","number","array","array","number","number"])}},zn=Z(o.pyJ);let Ns;const x={kernelName:o.Ncv,backendName:"wasm",setupFunc:function m(r){Ns=r.wasm.cwrap(o.Ncv,null,["number","number","number"])},kernelFunc:function _(r){const{inputs:n,backend:s}=r,{x:c,alpha:a}=n,i=s.dataIdMap.get(c.dataId).id,p=s.dataIdMap.get(a.dataId).id;let l=i;const f=c;let d=f;"float32"!==f.dtype&&(d=Se({backend:s,inputs:{x:c},attrs:{dtype:"float32"}}),l=s.dataIdMap.get(d.dataId).id);const u=s.makeOutput(c.shape,"float32"),h=s.dataIdMap.get(u.dataId).id;return Ns(l,p,h),"float32"!==f.dtype&&s.disposeData(d.dataId),u}};let R;const D={kernelName:o.kdj,backendName:"wasm",setupFunc:function E(r){R=r.wasm.cwrap(o.kdj,null,["number","number","number","number"])},kernelFunc:function P(r){const{backend:n,inputs:s,attrs:c}=r,{axis:a,keepDims:i}=c,{x:p}=s,l=n.dataIdMap.get(p.dataId).id;let f=l,d=p;const{transposed:u,axes:h,originalAxes:v,inputWasTransposed:g}=ce(p,a,n);let b=h;if(g){const k=n.dataIdMap.get(u.dataId).id;k!==l&&(d=u,f=k,b=o.C0T.getInnerMostAxes(b.length,d.shape.length))}o.C0T.assertAxesAreInnerMostDims("prod",b,d.shape.length);const[y,S]=o.C0T.computeOutAndReduceShapes(d.shape,b),A=o.ZSL.sizeFromShape(S),w=n.makeOutput(y,d.dtype);if(0!==o.ZSL.sizeFromShape(d.shape)){const k=n.dataIdMap.get(w.dataId).id;R(f,A,B[w.dtype],k)}if(g&&n.disposeData(u.dataId),i){const k=o.C0T.expandShapeToKeepDim(w.shape,v);w.shape=k}return w}};var F=Y(6251);const be={kernelName:o.Q6t,backendName:"wasm",kernelFunc:r=>{const{backend:n,attrs:s}=r,{start:c,stop:a,step:i,dtype:p}=s,l=(0,F.q)(c,a,i,p),f=n.makeOutput([l.length],p);return n.typedArrayFromHeap(f).set(l),f}},Rs=Z(o.sDr),$r=O(o.huO),eo=O(o.fUj),ge=O(o.P_L);let $e;const Oo={kernelName:o.hgw,backendName:"wasm",setupFunc:function Ts(r){$e=r.wasm.cwrap(o.hgw,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function Bo(r){const{backend:n,inputs:s,attrs:c}=r,{images:a}=s,{alignCorners:i,halfPixelCenters:p,size:l}=c,[f,d]=l,[u,h,v,g]=a.shape,b=[u,f,d,g];let S,y=n.dataIdMap.get(a.dataId);"float32"!==y.dtype&&(S=Se({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),y=n.dataIdMap.get(S.dataId));const A=y.id,w=n.makeOutput(b,"float32");if(0===o.ZSL.sizeFromShape(a.shape))return w;const k=n.dataIdMap.get(w.dataId).id;return $e(A,u,h,v,g,f,d,i?1:0,p?1:0,k),null!=S&&n.disposeData(S.dataId),w}};let oo;const Ho={kernelName:o.FCQ,backendName:"wasm",setupFunc:function Lo(r){oo=r.wasm.cwrap(o.FCQ,null,["number","number","number","array","array","boolean"])},kernelFunc:function Wo(r){const{inputs:n,backend:s,attrs:c}=r,{images:a,dy:i}=n,{alignCorners:p}=c,l=s.makeOutput(a.shape,"float32");let d,f=s.dataIdMap.get(a.dataId);return"float32"!==f.dtype&&(d=Se({backend:s,inputs:{x:a},attrs:{dtype:"float32"}}),f=s.dataIdMap.get(d.dataId)),oo(s.dataIdMap.get(a.dataId).id,s.dataIdMap.get(i.dataId).id,s.dataIdMap.get(l.dataId).id,new Uint8Array(new Int32Array(a.shape).buffer),new Uint8Array(new Int32Array(i.shape).buffer),p),null!=d&&s.disposeData(d.dataId),l}};let uo;const Go={kernelName:o.jOE,backendName:"wasm",setupFunc:function zo(r){uo=r.wasm.cwrap(o.jOE,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function Vo(r){const{backend:n,inputs:s,attrs:c}=r,{images:a}=s,{alignCorners:i,halfPixelCenters:p,size:l}=c,[f,d]=l,[u,h,v,g]=a.shape,y=n.makeOutput([u,f,d,g],"float32");if(0===o.ZSL.sizeFromShape(a.shape))return y;let A,S=n.dataIdMap.get(a.dataId);"float32"!==S.dtype&&(A=Se({backend:n,inputs:{x:a},attrs:{dtype:"float32"}}),S=n.dataIdMap.get(A.dataId));const w=S.id,k=n.dataIdMap.get(y.dataId).id;return uo(w,u,h,v,g,f,d,i?1:0,p?1:0,k),null!=A&&n.disposeData(A.dataId),y}};let io;const Zo={kernelName:o.XQy,backendName:"wasm",setupFunc:function Uo(r){io=r.wasm.cwrap(o.XQy,null,["number","number","number","array","array","boolean"])},kernelFunc:function jo(r){const{inputs:n,backend:s,attrs:c}=r,{images:a,dy:i}=n,{alignCorners:p}=c,l=s.makeOutput(a.shape,"float32");let d,f=s.dataIdMap.get(a.dataId);return"float32"!==f.dtype&&(d=Se({backend:s,inputs:{x:a},attrs:{dtype:"float32"}}),f=s.dataIdMap.get(d.dataId)),io(s.dataIdMap.get(a.dataId).id,s.dataIdMap.get(i.dataId).id,s.dataIdMap.get(l.dataId).id,new Uint8Array(new Int32Array(a.shape).buffer),new Uint8Array(new Int32Array(i.shape).buffer),p),null!=d&&s.disposeData(d.dataId),l}};let co;const Xo={kernelName:o.D7i,backendName:"wasm",kernelFunc:function $o(r){const{inputs:n,backend:s,attrs:c}=r,{x:a}=n,{dims:i}=c,p=o.ZSL.parseAxisParam(i,a.shape);if(0===a.shape.length)return Ie({inputs:{x:a},backend:s});const l=s.makeOutput(a.shape,a.dtype),f=s.dataIdMap.get(a.dataId).id,d=s.dataIdMap.get(l.dataId).id,u=new Uint8Array(new Int32Array(p).buffer),h=new Uint8Array(new Int32Array(a.shape).buffer);co(f,u,p.length,h,a.shape.length,d);const v=ue({inputs:{x:l},attrs:{shape:a.shape},backend:s});return s.disposeData(l.dataId),v},setupFunc:function qo(r){co=r.wasm.cwrap(o.D7i,null,["number","array","number","array","number","number"])}};let po;const Qo={kernelName:o.BK4,backendName:"wasm",kernelFunc:function Jo(r){const{inputs:n,backend:s,attrs:c}=r,{image:a}=n,{radians:i,fillValue:p,center:l}=c,f=s.makeOutput(a.shape,a.dtype),d=s.dataIdMap.get(a.dataId).id,u=s.dataIdMap.get(f.dataId).id,[h,v,g,b]=a.shape,[y,S]=o.C0T.getImageCenter(l,v,g),k="number"==typeof p?[p,p,p,0===p?0:255]:[...p,255],C=new Uint8Array(new Int32Array(k).buffer);return po(d,h,v,g,b,i,y,S,C,k.length,u),f},setupFunc:function Ko(r){po=r.wasm.cwrap(o.BK4,null,["number","number","number","number","number","number","number","number","array","number","number"])}},Yo=O(o.hVg),eu=O(o.TOR);let lo;const au={kernelName:o.pJc,backendName:"wasm",setupFunc:function tu(r){lo=r.wasm.cwrap(o.pJc,null,["number","number","number","number","number","number","array","number","number"])},kernelFunc:function nu(r){const{backend:n,inputs:s,attrs:c}=r,{indices:a,updates:i}=s,{shape:p}=c,l=n.makeOutput(p,i.dtype);if(0===o.ZSL.sizeFromShape(p))return l;const{sliceRank:f,numUpdates:d,sliceSize:u,strides:h,outputSize:v}=o.g23.calculateShapes(i,a,p),b=n.dataIdMap.get(a.dataId).id,S=n.dataIdMap.get(i.dataId).id,A=new Uint8Array(new Int32Array(h).buffer),w=n.dataIdMap.get(l.dataId).id;return lo(b,S,B[i.dtype],f,d,u,A,v,w),l}};let mo;const ou={kernelName:o.uWl,backendName:"wasm",setupFunc:function ru(r){mo=r.wasm.cwrap(o.uWl,null,["number","number","number","number","number","number","bool","number"])},kernelFunc:function su(r){const{inputs:n,backend:s,attrs:c}=r,{sortedSequence:a,values:i}=n,{side:p}=c;if(a.dtype!==i.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${a.dtype} and ${i.dtype}`);const l=s.makeOutput(i.shape,"int32");function f(d){return s.dataIdMap.get(d.dataId).id}return mo(f(a),f(i),a.shape[0],a.shape[1],i.shape[1],B[a.dtype],"left"===p,f(l)),l}};let fo;const du={kernelName:o.l6P,backendName:"wasm",kernelFunc:function iu(r){const{inputs:n,backend:s}=r,{condition:c,t:a,e:i}=n,p=s.dataIdMap.get(c.dataId).id,l=s.dataIdMap.get(a.dataId).id,f=s.dataIdMap.get(i.dataId).id,d=s.makeOutput(a.shape,a.dtype),u=s.dataIdMap.get(d.dataId).id,h=c.shape.length,g=0===h||h>1||1===a.shape.length?1:o.ZSL.sizeFromShape(a.shape.slice(1));return fo(p,l,f,g,u),d},setupFunc:function uu(r){fo=r.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}},cu=O(o.u$b);let ho;const mu={kernelName:"Sigmoid",backendName:"wasm",setupFunc:function pu(r){ho=r.wasm.cwrap(o.vI1,null,["number","number"])},kernelFunc:function lu(r){const{backend:n,inputs:{x:s}}=r,c=n.dataIdMap.get(s.dataId).id,a=n.makeOutput(s.shape,s.dtype),i=n.dataIdMap.get(a.dataId).id;return 0===o.ZSL.sizeFromShape(a.shape)||ho(c,i),a}},fu=O(o.YVe),hu=O(o.hql),gu=O(o.J3C),_u=O(o.Fin),yu={kernelName:o.A8B,backendName:"wasm",kernelFunc:function bu(r){const{inputs:n,backend:s,attrs:c}=r,{x:a}=n,{blockShape:i,paddings:p}=c,l=o.ZSL.sizeFromShape(i),f=[[0,0]];f.push(...p);for(let H=1+i.length;H<a.shape.length;++H)f.push([0,0]);const d=Zr.kernelFunc({inputs:{x:a},backend:s,attrs:{paddings:f,constantValue:0}}),u=o.C0T.getReshaped(d.shape,i,l,!1),h=o.C0T.getPermuted(u.length,i.length,!1),v=o.C0T.getReshapedPermuted(d.shape,i,l,!1),y=ue({inputs:{x:d},backend:s,attrs:{shape:u}}),w=J({inputs:{x:y},backend:s,attrs:{perm:h}}),z=ue({inputs:{x:w},backend:s,attrs:{shape:v}});return s.disposeData(d.dataId),s.disposeData(y.dataId),s.disposeData(w.dataId),z}};let go;const Su={kernelName:o.C8s,backendName:"wasm",setupFunc:function Iu(r){go=r.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function vu(r){const{backend:n,inputs:s}=r,{indices:c,values:a,denseShape:i,defaultValue:p}=s,l=c.shape[0],f=c.shape[1],d=n.readSync(i.dataId)[0],u=[l+d,f],h=n.dataIdMap.get(c.dataId).id,v=n.dataIdMap.get(a.dataId).id,g=n.dataIdMap.get(p.dataId).id,b=n.makeOutput(u,c.dtype),y=n.dataIdMap.get(b.dataId).id,S=n.makeOutput(u.slice(0,1),a.dtype),A=n.dataIdMap.get(S.dataId).id,w=n.makeOutput([d],"bool"),k=n.dataIdMap.get(w.dataId).id,C=n.makeOutput([l],c.dtype),z=n.dataIdMap.get(C.dataId).id,H=n.makeOutput([4],"int32"),G=n.dataIdMap.get(H.dataId).id,X=go(h,v,B[a.dtype],l,d,f,g,y,A,k,z,G),K=n.readSync(H.dataId);let U;switch(K[0]){case 1:U=o.C0T.getSparseFillEmptyRowsIndicesDenseShapeMismatch(K[1]);break;case 2:U=o.C0T.getSparseFillEmptyRowsNegativeIndexErrorMessage(K[1],K[2]);break;case 3:U=o.C0T.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(K[1],K[2],K[3]);break;default:U=""}if(n.disposeData(H.dataId),U)throw n.disposeData(b.dataId),n.disposeData(S.dataId),n.disposeData(w.dataId),n.disposeData(C.dataId),new Error(U);let ne=b,ae=S;return X!==u[0]&&(ne=Ne({inputs:{x:b},attrs:{begin:0,size:[X,f]},backend:n}),ae=Ne({inputs:{x:S},attrs:{begin:0,size:X},backend:n}),n.disposeData(b.dataId),n.disposeData(S.dataId)),[ne,ae,w,C]}};let _o;const Mu={kernelName:o.BoJ,backendName:"wasm",setupFunc:function wu(r){_o=r.wasm.cwrap(o.BoJ,null,["number","number","number","number","number","number","number"])},kernelFunc:function ku(r){const{backend:n,inputs:s}=r,{inputIndices:c,inputShape:a,newShape:i}=s;if(2!==c.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${c.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const p=n.dataIdMap.get(c.dataId).id,l=n.dataIdMap.get(a.dataId).id,f=n.dataIdMap.get(i.dataId).id,d=c.shape[0],u=o.ZSL.sizeFromShape(i.shape),h=n.makeOutput([d,u],c.dtype),v=n.dataIdMap.get(h.dataId).id,g=n.makeOutput([u],i.dtype),b=n.dataIdMap.get(g.dataId).id,y=n.makeOutput([3],"int32"),S=n.dataIdMap.get(y.dataId).id;_o(p,l,f,d,v,b,S);const A=n.readSync(y.dataId);let w;switch(A[0]){case 0:w=o.C0T.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(A[1],A[2]);break;case 1:w=o.C0T.getSparseReshapeNegativeOutputDimErrorMessage(A[1],A[2]);break;case 2:w=o.C0T.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{const k=Array.from(n.readSync(a.dataId)),C=Array.from(n.readSync(g.dataId));w=o.C0T.getSparseReshapeInputOutputMultipleErrorMessage(k,C);break}case 4:{const k=Array.from(n.readSync(a.dataId)),C=Array.from(n.readSync(g.dataId));w=o.C0T.getSparseReshapeInputOutputMismatchErrorMessage(k,C);break}default:w=""}if(n.disposeData(y.dataId),w)throw n.disposeData(h.dataId),n.disposeData(g.dataId),new Error(w);return[h,g]}};let bo;function yo(r){bo=r.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function Io(r,n){const{backend:s,inputs:c}=r,{data:a,indices:i,segmentIds:p}=c,l=i.shape[0],f=s.readSync(p.dataId,l-1,l)[0],u=l>0?f+1:0;if(u<0)throw new Error(o.C0T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const h=a.shape.slice();h[0]=u;const v=s.dataIdMap.get(a.dataId).id,g=s.dataIdMap.get(i.dataId).id,b=s.dataIdMap.get(p.dataId).id,y=s.makeOutput(h,a.dtype),S=s.dataIdMap.get(y.dataId).id,A=s.makeOutput([4],"int32"),w=s.dataIdMap.get(A.dataId).id;bo(v,B[a.dtype],a.shape[0],g,b,S,w,n,0);const k=s.readSync(A.dataId);let C;switch(k[0]){case 0:C=o.C0T.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break;case 1:C=o.C0T.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break;case 2:C=o.C0T.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(k[1],k[2]);break;case 3:C=o.C0T.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(k[1],k[2],k[3]);break;default:C=""}if(s.disposeData(A.dataId),C)throw s.disposeData(y.dataId),new Error(C);return y}const xu={kernelName:o.L6G,backendName:"wasm",setupFunc:yo,kernelFunc:function Au(r){return Io(r,!0)}},Cu={kernelName:o.DvZ,backendName:"wasm",setupFunc:yo,kernelFunc:function Du(r){return Io(r,!1)}};let vo;const Ru={kernelName:o.jgd,backendName:"wasm",setupFunc:function Fu(r){vo=r.wasm.cwrap(o.jgd,null,["number","number","number","number","number","number","number","number","array","number","number"])},kernelFunc:function Nu(r){const{backend:n,inputs:s,attrs:c}=r,{sparseIndices:a,sparseValues:i,defaultValue:p}=s,{outputShape:l}=c,f=n.makeOutput(l,p.dtype);if(0===o.ZSL.sizeFromShape(l))return f;const{sliceRank:d,numUpdates:u,sliceSize:h,strides:v,outputSize:g}=o.C0T.calculateShapes(i,a,l),b=n.dataIdMap.get(a.dataId).id,y=n.dataIdMap.get(i.dataId).id,S=n.dataIdMap.get(p.dataId).id,A=new Uint8Array(new Int32Array(v).buffer),w=n.dataIdMap.get(f.dataId).id;return vo(b,y,i.shape.length,S,B[p.dtype],d,u,h,A,g,w),f}},Pu={kernelName:o.Blb,backendName:"wasm",kernelFunc:function Tu(r){const{inputs:n,attrs:s,backend:c}=r,{x:a}=n,{numOrSizeSplits:i,axis:p}=s,l=o.ZSL.parseAxisParam(p,a.shape)[0],f=o.C0T.prepareSplitSize(a,i,l),d=new Array(a.shape.length).fill(0),u=a.shape.slice();return f.map(h=>{const v=[...u];v[l]=h;const g=Ne({inputs:{x:a},attrs:{begin:d,size:v},backend:c});return d[l]+=h,g})}},Eu=O(o.dFH),Bu=O(o.M6A),Ou=Z(o.Ddj);let So;const Hu={kernelName:o.pnw,backendName:"wasm",setupFunc:function Lu(r){So=r.wasm.cwrap(o.pnw,null,["number","number","number","number"])},kernelFunc:function Wu(r){const{backend:n,inputs:s,attrs:c}=r,{alpha:a}=c,{x:i}=s,p=n.dataIdMap.get(i.dataId).id,l=n.makeOutput(i.shape,i.dtype),f=n.dataIdMap.get(l.dataId).id;return So(p,a,B[i.dtype],f),l}};let wo;const Gu={kernelName:o.UcO,backendName:"wasm",setupFunc:function zu(r){wo=r.wasm.cwrap(o.UcO,null,["number","array","number","array","array","array","array","array","number","number"])},kernelFunc:function Vu(r){const{backend:n,inputs:s,attrs:c}=r,{x:a}=s,{begin:i,end:p,strides:l,beginMask:f,endMask:d,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:v}=c,{finalShapeSparse:g,finalShape:b,isIdentity:y,sliceDim0:S,isSimpleSlice:A,begin:w,end:k,strides:C}=o.Kro.sliceInfo(a.shape,i,p,l,f,d,u,h,v);let z;if(y)z=ue({inputs:{x:a},backend:n,attrs:{shape:b}});else if(S||A){o.ZSL.assert(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);const H=o.Kro.computeOutShape(w,k,C),G=Ne({inputs:{x:a},backend:n,attrs:{begin:w,size:H}});z=ue({inputs:{x:G},backend:n,attrs:{shape:b}}),n.disposeData(G.dataId)}else{const H=n.makeOutput(g,"float32"),G=n.dataIdMap.get(a.dataId).id,X=new Uint8Array(new Int32Array(o.ZSL.computeStrides(a.shape)).buffer),K=new Uint8Array(new Int32Array(w).buffer),U=new Uint8Array(new Int32Array(k).buffer),ne=new Uint8Array(new Int32Array(C).buffer),ae=new Uint8Array(new Int32Array(g).buffer),he=new Uint8Array(new Int32Array(o.ZSL.computeStrides(g)).buffer),Xe=n.dataIdMap.get(H.dataId).id;wo(G,X,a.shape.length,K,U,ne,ae,he,g.length,Xe),z=ue({inputs:{x:H},backend:n,attrs:{shape:b}}),n.disposeData(H.dataId)}return z}};var Uu=Y(48953);const Zu={kernelName:o.YAb,backendName:"wasm",kernelFunc:function ju(r){const{backend:n,inputs:s,attrs:c}=r,{data:a,dataSplits:i}=s,{separator:p,nGramWidths:l,leftPad:f,rightPad:d,padWidth:u,preserveShortSequences:h}=c,v=n.readSync(a.dataId),g=n.readSync(i.dataId),[b,y]=(0,Uu.G)(v,g,p,l,f,d,u,h),S=n.makeOutput([b.length],"string");n.dataIdMap.get(S.dataId).stringBytes=b;const w=n.makeOutput(i.shape,"int32");return n.typedArrayFromHeap(w).set(y),[S,w]}};var qu=Y(70065);const Xu={kernelName:o.iW0,backendName:"wasm",kernelFunc:function $u(r){const{backend:n,inputs:s,attrs:c}=r,{input:a,delimiter:i}=s,{skipEmpty:p}=c,l=n.readSync(a.dataId),f=n.readSync(i.dataId),[d,u,h]=(0,qu.S)(l,f[0],p),v=u.length,g=n.makeOutput([v,2],"int32");n.typedArrayFromHeap(g).set(d);const y=n.makeOutput([v],"string");n.dataIdMap.get(y.dataId).stringBytes=u;const A=n.makeOutput([2],"int32");return n.typedArrayFromHeap(A).set(h),[g,y,A]}};var Ku=Y(72856);const Qu={kernelName:o.$jE,backendName:"wasm",kernelFunc:function Ju(r){const{backend:n,inputs:s,attrs:c}=r,{input:a}=s,{numBuckets:i}=c,p=n.readSync(a.dataId),l=(0,Ku.f)(p,i),f=n.makeOutput(a.shape,"int32");return n.typedArrayFromHeap(f).set(l),f}},Yu=Z(o.PbM);let ko;const ni={kernelName:o.WuN,backendName:"wasm",setupFunc:function ei(r){ko=r.wasm.cwrap(o.WuN,null,["number","number","number","number"])},kernelFunc:function ti(r){const{backend:n,inputs:s,attrs:c}=r,{axis:a,keepDims:i}=c,{x:p}=s,l=n.dataIdMap.get(p.dataId).id;let f=l,d=p;const{transposed:u,axes:h,originalAxes:v,inputWasTransposed:g}=ce(p,a,n);let b=h;if(g){const k=n.dataIdMap.get(u.dataId).id;k!==l&&(d=u,f=k,b=o.C0T.getInnerMostAxes(b.length,d.shape.length))}o.C0T.assertAxesAreInnerMostDims("sum",b,d.shape.length);const[y,S]=o.C0T.computeOutAndReduceShapes(d.shape,b),A=o.ZSL.sizeFromShape(S),w=n.makeOutput(y,d.dtype);if(0!==o.ZSL.sizeFromShape(d.shape)){const k=n.dataIdMap.get(w.dataId).id;ko(f,A,B[w.dtype],k)}if(g&&n.disposeData(u.dataId),i){const k=o.C0T.expandShapeToKeepDim(w.shape,v);w.shape=k}return w}},ai=O(o.oFs),ri=O(o.iuW);let Mo;const ui={kernelName:o.X4r,backendName:"wasm",setupFunc:function si(r){Mo=r.wasm.cwrap(o.X4r,null,["number","number","number","number","number","number","array","number","number","number"])},kernelFunc:function oi(r){const{backend:n,inputs:s}=r,{tensor:a,indices:i,updates:p}=s,l=n.makeOutput(a.shape,a.dtype);if(0===o.ZSL.sizeFromShape(a.shape))return l;const{sliceRank:f,numUpdates:d,sliceSize:u,strides:h,outputSize:v}=o.g23.calculateShapes(p,i,a.shape),b=n.dataIdMap.get(i.dataId).id,S=n.dataIdMap.get(p.dataId).id,w=n.dataIdMap.get(a.dataId).id,k=new Uint8Array(new Int32Array(h).buffer),C=n.dataIdMap.get(l.dataId).id;return Mo(b,S,B[p.dtype],f,d,u,k,v,C,w),l}};let Ao;const ci={kernelName:o.FAs,backendName:"wasm",setupFunc:function ii(r){Ao=r.wasm.cwrap(o.FAs,null,["number","array","number","array","number","number"])},kernelFunc:function di(r){const{inputs:n,backend:s,attrs:c}=r,{x:a}=n,i=s.dataIdMap.get(a.dataId).id,{reps:p}=c,l=new Array(a.shape.length);for(let v=0;v<l.length;v++)l[v]=a.shape[v]*p[v];const f=new Uint8Array(new Int32Array(a.shape).buffer),d=new Uint8Array(new Int32Array(l).buffer),u=s.makeOutput(l,a.dtype),h=s.dataIdMap.get(u.dataId).id;return Ao(i,f,a.shape.length,d,l.length,B[u.dtype],h),u}};let xo;const mi={kernelName:o.TBb,backendName:"wasm",setupFunc:function pi(r){xo=r.wasm.cwrap(o.TBb,null,["number","array","number","number","number","bool","number","number"])},kernelFunc:({inputs:r,backend:n,attrs:s})=>{const{x:c}=r,{k:a,sorted:i}=s,p=n.dataIdMap.get(c.dataId).id,l=new Uint8Array(new Int32Array(c.shape).buffer),f=c.shape.slice();f[f.length-1]=a;const d=n.makeOutput(f,c.dtype),u=n.dataIdMap.get(d.dataId).id,h=n.makeOutput(f,"int32"),v=n.dataIdMap.get(h.dataId).id;return xo(p,l,c.shape.length,B[c.dtype],a,i,u,v),[d,h]}};let Do;const gi={kernelName:o.dLy,backendName:"wasm",setupFunc:function fi(r){Do=r.wasm.cwrap(o.dLy,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])},kernelFunc:function hi(r){const{backend:n,inputs:s,attrs:c}=r,{image:a,transforms:i}=s,{interpolation:p,fillMode:l,fillValue:f,outputShape:d}=c,[u,h,v,g]=a.shape,[b,y]=null!=d?d:[h,v],S=[u,b,y,g],A=new Uint8Array(new Int32Array(o.ZSL.computeStrides(a.shape)).buffer),w=new Uint8Array(new Int32Array(o.ZSL.computeStrides(S)).buffer),k=n.makeOutput(S,a.dtype),C=n.dataIdMap.get(k.dataId).id,H=n.dataIdMap.get(a.dataId).id,X=n.dataIdMap.get(i.dataId).id,K="nearest"===p?1:2;let U;switch(l){case"constant":default:U=1;break;case"reflect":U=2;break;case"wrap":U=3;break;case"nearest":U=4}return Do(H,X,i.shape[0]>1,u,b,y,g,v,h,A,a.shape.length-1,w,S.length-1,K,U,f,C),k}};var _i=Y(73033);const ki=[ke,Pt,st,e,We,xe,it,se,ns,qn,$n,ye,Lt,j,pt,lt,Xt,Vt,jt,Jt,Jn,Re,Yt,Yn,et,me,rs,je,aa,nn,sa,ua,sn,on,ca,la,fa,ga,St,Ia,Sa,ka,os,Da,Na,Ra,Ea,Ba,Oa,La,Wa,Ha,za,Ua,ja,Za,Xa,Qa,tr,rr,ur,ir,dr,De,cr,pr,lr,hr,gr,_r,Ir,Sr,vr,wr,kr,Mr,Ar,Cr,Rr,Er,Br,Wr,Hr,at,M,$,_e,Vr,Oe,Os,Vs,Gs,Us,js,$s,On,Qs,Ms,Ds,jr,Wn,Zr,zn,x,D,be,Rs,$r,eo,ge,pe,Oo,Ho,Go,Zo,Xo,Qo,Yo,eu,au,ou,du,cu,mu,fu,hu,gu,Qt,Ws,_u,yu,Su,Mu,xu,Cu,Ru,Pu,Eu,Bu,Ou,Hu,Gu,Zu,Xu,Qu,Yu,ni,ai,ri,ui,ci,mi,gi,ut,{kernelName:o.EwU,backendName:"wasm",kernelFunc:function bi(r){const{inputs:n,attrs:s,backend:c}=r,{axis:a}=s,{x:i}=n,{outputValues:p,outputShape:l,indices:f}=(0,_i.w)(c.readSync(i.dataId),a,i.shape,i.dtype);return[c.makeOutput(l,i.dtype,void 0,p),c.makeOutput([f.length],"int32",void 0,f)]}},{kernelName:o.dXR,backendName:"wasm",kernelFunc:function Ii(r){const{inputs:n,backend:s,attrs:c}=r,{value:a}=n;let{axis:i}=c;i<0&&(i+=a.shape.length);const p=a.shape[i],l=a.shape.length,f=new Array(l-1);let d=0;for(let g=0;g<l;g++)g!==i&&(f[d++]=a.shape[g]);const u=new Array(p),h=new Array(l).fill(0),v=a.shape.slice();v[i]=1;for(let g=0;g<u.length;g++)h[i]=g,u[g]=Ne({inputs:{x:a},attrs:{begin:h,size:v},backend:s});return u.map(({dataId:g,dtype:b})=>({dataId:g,dtype:b,shape:f}))}},{kernelName:o.xJ3,backendName:"wasm",kernelFunc:function Si(r){const{inputs:{x:n},backend:s}=r,c=s.makeOutput(n.shape,n.dtype);return s.typedArrayFromHeap(c).fill(0),c}}];for(const r of ki)(0,o.tAK)(r);var Vn=Y(10467);const to=(0,o._K2)();to.registerFlag("WASM_HAS_SIMD_SUPPORT",(0,Vn.A)(function*(){try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}})),to.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",(0,Vn.A)(function*(){if(to.get("IS_NODE"))return!1;try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}}));var Co=Y(62564),Mi=Y.n(Co),Ai=Y(74466),Fo=Y(94732),xi=Y.n(Fo);const No=Mi()||Co,Di=xi()||Fo;class Ro extends o.uI_{constructor(n){super(),this.wasm=n,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(Po),ao=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new o.GJx(this,(0,o.Hi9)())}write(n,s,c){const a={id:this.dataIdNextNumber++};return this.move(a,n,s,c,1),a}numDataIds(){return this.dataIdMap.numDataIds()}time(n){return(0,Vn.A)(function*(){const s=o.ZSL.now();return n(),{kernelMs:o.ZSL.now()-s}})()}move(n,s,c,a,i){const p=this.dataIdNextNumber++;if("string"===a)return void this.dataIdMap.set(n,{id:p,stringBytes:s,shape:c,dtype:a,memoryOffset:null,refCount:i});const l=o.ZSL.sizeFromShape(c),f=l*o.ZSL.bytesPerElement(a),d=this.wasm._malloc(f)>>>0;this.dataIdMap.set(n,{id:p,memoryOffset:d,shape:c,dtype:a,refCount:i}),this.wasm.tfjs.registerTensor(p,l,d),null!=s&&this.wasm.HEAPU8.set(new Uint8Array(s.buffer,s.byteOffset,f),d)}read(n){var s=this;return(0,Vn.A)(function*(){return s.readSync(n)})()}readSync(n,s,c){const{memoryOffset:a,dtype:i,shape:p,stringBytes:l}=this.dataIdMap.get(n);if("string"===i)return null!=s&&0!==s||!(null==c||c>=l.length)?l.slice(s,c):l;s=s||0,c=c||o.ZSL.sizeFromShape(p);const f=o.ZSL.bytesPerElement(i);return function Ni(r,n){switch(n){case"float32":return new Float32Array(r);case"int32":return new Int32Array(r);case"bool":return new Uint8Array(r);default:throw new Error(`Unknown dtype ${n}`)}}(this.wasm.HEAPU8.slice(a+s*f,a+c*f).buffer,i)}disposeData(n,s=!1){if(this.dataIdMap.has(n)){const c=this.dataIdMap.get(n);if(c.refCount--,!s&&c.refCount>0)return!1;this.wasm._free(c.memoryOffset),this.wasm.tfjs.disposeData(c.id),this.dataIdMap.delete(n)}return!0}refCount(n){return this.dataIdMap.has(n)?this.dataIdMap.get(n).refCount:0}incRef(n){const s=this.dataIdMap.get(n);null!=s&&s.refCount++}floatPrecision(){return 32}getMemoryOffset(n){return this.dataIdMap.get(n).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(n,s,c,a){let i;if(null==c)i=this.write(null!=a?a:null,n,s);else{const p=this.dataIdNextNumber++;i={id:p},this.dataIdMap.set(i,{id:p,memoryOffset:c,shape:n,dtype:s,refCount:1});const l=o.ZSL.sizeFromShape(n);this.wasm.tfjs.registerTensor(p,l,c)}return{dataId:i,shape:n,dtype:s}}typedArrayFromHeap({shape:n,dtype:s,dataId:c}){const a=this.wasm.HEAPU8.buffer,{memoryOffset:i}=this.dataIdMap.get(c),p=o.ZSL.sizeFromShape(n);switch(s){case"float32":return new Float32Array(a,i,p);case"int32":return new Int32Array(a,i,p);case"bool":return new Uint8Array(a,i,p);default:throw new Error(`Unknown dtype ${s}`)}}}function To(r,n,s){if(null!=Xr)return Xr;let c="tfjs-backend-wasm.wasm";return r&&n?c="tfjs-backend-wasm-threaded-simd.wasm":r&&(c="tfjs-backend-wasm-simd.wasm"),null!=Un&&null!=Un[c]?Un[c]:s+c}function no(){return(no=(0,Vn.A)(function*(){const[r,n]=yield Promise.all([(0,o._K2)().getAsync("WASM_HAS_SIMD_SUPPORT"),(0,o._K2)().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((s,c)=>{const a={locateFile:(l,f)=>{if(l.endsWith(".worker.js")){const d=Ai.$.replace(/\n/g,"\\n"),u=new Blob([d],{type:"application/javascript"});return URL.createObjectURL(u)}return l.endsWith(".wasm")?To(r,n,null!=Gn?Gn:f):f+l}};Ps&&(a.instantiateWasm=function Ci(r){return(n,s)=>(o.ZSL.fetch(r,{credentials:"same-origin"}).then(c=>{c.ok||n.env.a(`failed to load wasm binary file at '${r}'`),c.arrayBuffer().then(a=>{WebAssembly.instantiate(a,n).then(i=>{s(i.instance,i.module)})})}),{})}(To(r,n,null!=Gn?Gn:"")));let p,i=!1;a.onAbort=()=>{i||jn||(jn=!0,c({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))},n&&r&&null==Xr?(a.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+No.toString()],{type:"text/javascript"}),p=No(a)):p=Di(a),p.then(l=>{i=!0,jn=!1,l.tfjs={init:l.cwrap("init",null,[]),initWithThreadsCount:l.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:l.cwrap("get_threads_count","number",[]),registerTensor:l.cwrap("register_tensor",null,["number","number","number"]),disposeData:l.cwrap("dispose_data",null,["number"]),dispose:l.cwrap("dispose",null,[])},s({wasm:l})}).catch(c)})})).apply(this,arguments)}const Ri=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"];let Xr=null,Gn=null,Un={},jn=!1,Ps=!1;function Ti(r,n=!1){if((0,o.fLc)("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),jn)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");Xr=r,Ps=n}function Pi(r,n=!1){if(jn)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if("string"==typeof r)Gn=r;else{Un=r;const s=Ri.filter(c=>null==Un[c]);if(s.length>0)throw new Error(`There were no entries found for the following binaries: ${s.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}Ps=n}let Po=-1,ao=-1;function Ei(r){Po=r}function Bi(){if(-1===ao)throw new Error("WASM backend not initialized.");return ao}const Oi="4.22.0";(0,o.gJX)("wasm",(0,Vn.A)(function*(){const{wasm:r}=yield function Fi(){return no.apply(this,arguments)}();return new Ro(r)}),2)},62564:(Tt,ts,Y)=>{var B,o=(B=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0,typeof __filename<"u"&&(B=B||__filename),function(re){function Te(){return j.buffer!=oe&&pe(j.buffer),Ut}function ke(){return j.buffer!=oe&&pe(j.buffer),qt}function O(){return j.buffer!=oe&&pe(j.buffer),$t}function st(){return j.buffer!=oe&&pe(j.buffer),ue}var Z,Ae,We,e=typeof(re=re||{})<"u"?re:{};e.ready=new Promise(function(m,_){Z=m,Ae=_}),typeof process<"u"&&process.listeners&&(We={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var ve,ut,ce,ie=Object.assign({},e),ot=[],xe=(m,_)=>{throw _},Ie="object"==typeof window,De="function"==typeof importScripts,de="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,ee=e.ENVIRONMENT_IS_PTHREAD||!1,J="";function Et(m){return e.locateFile?e.locateFile(m,J):J+m}if(de){var He=Y(9893),it=Y(45281);let m;J=De?it.dirname(J)+"/":__dirname+"/",ve=(_,x)=>(_=et(_)?new URL(_):it.normalize(_),He.readFileSync(_,x?void 0:"utf8")),ce=_=>{var x=ve(_,!0);return x.buffer||(x=new Uint8Array(x)),x},ut=(_,x,R)=>{_=et(_)?new URL(_):it.normalize(_),He.readFile(_,function(E,P){E?R(E):x(P.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),ot=process.argv.slice(2),process.on("uncaughtException",function(_){if(!(_ instanceof je))throw _}),process.on("unhandledRejection",function(_){throw _}),xe=(_,x)=>{if(Ge())throw process.exitCode=_,x;(function Je(m){m instanceof je||se("exiting due to exception: "+m)})(x),process.exit(_)},e.inspect=function(){return"[Emscripten Module object]"};try{m=Y(13556)}catch(_){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),_}global.Worker=m.Worker}else(Ie||De)&&(De?J=self.location.href:typeof document<"u"&&document.currentScript&&(J=document.currentScript.src),typeof B<"u"&&B&&(J=B),J=0!==J.indexOf("blob:")?J.substr(0,J.replace(/[?#].*/,"").lastIndexOf("/")+1):"",de||(ve=m=>{var _=new XMLHttpRequest;return _.open("GET",m,!1),_.send(null),_.responseText},De&&(ce=m=>{var _=new XMLHttpRequest;return _.open("GET",m,!1),_.responseType="arraybuffer",_.send(null),new Uint8Array(_.response)}),ut=(m,_,x)=>{var R=new XMLHttpRequest;R.open("GET",m,!0),R.responseType="arraybuffer",R.onload=()=>{200==R.status||0==R.status&&R.response?_(R.response):x()},R.onerror=x,R.send(null)}));de&&typeof performance>"u"&&(global.performance=Y(97244).performance);var Ot=console.log.bind(console),dt=console.warn.bind(console);de&&(Ot=m=>He.writeSync(1,m+"\n"),dt=m=>He.writeSync(2,m+"\n"));var ye,ct=e.print||Ot,se=e.printErr||dt;Object.assign(e,ie),ie=null,e.arguments&&(ot=e.arguments),e.quit&&(xe=e.quit),Atomics,Atomics,Atomics,e.wasmBinary&&(ye=e.wasmBinary);var Lt=e.noExitRuntime||!0;"object"!=typeof WebAssembly&&Ue("no native wasm support detected");var j,pt,ze,oe,Gt,Ut,qt,$t,ue,Ce=!1,lt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function Wt(m,_,x){for(var R=(_>>>=0)+x,E=_;m[E]&&!(E>=R);)++E;if(E-_>16&&m.buffer&&lt)return lt.decode(m.buffer instanceof SharedArrayBuffer?m.slice(_,E):m.subarray(_,E));for(var P="";_<E;){var D=m[_++];if(128&D){var F=63&m[_++];if(192!=(224&D)){var Q=63&m[_++];if((D=224==(240&D)?(15&D)<<12|F<<6|Q:(7&D)<<18|F<<12|Q<<6|63&m[_++])<65536)P+=String.fromCharCode(D);else{var be=D-65536;P+=String.fromCharCode(55296|be>>10,56320|1023&be)}}else P+=String.fromCharCode((31&D)<<6|F)}else P+=String.fromCharCode(D)}return P}function pe(m){oe=m,e.HEAP8=Gt=new Int8Array(m),e.HEAP16=new Int16Array(m),e.HEAP32=qt=new Int32Array(m),e.HEAPU8=Ut=new Uint8Array(m),e.HEAPU16=new Uint16Array(m),e.HEAPU32=$t=new Uint32Array(m),e.HEAPF32=new Float32Array(m),e.HEAPF64=ue=new Float64Array(m)}ee&&(oe=e.buffer);var Ve=e.INITIAL_MEMORY||16777216;if(ee)j=e.wasmMemory,oe=e.buffer;else if(e.wasmMemory)j=e.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:Ve/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw se("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),de&&se("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");j&&(oe=j.buffer),Ve=oe.byteLength,pe(oe);var Pe,Kt=[],Jt=[],Fe=[];function Ge(){return Lt}function le(){!ee&&_t(Jt)}var Ee=0,Ye=null,Re=null;function Ue(m){e.onAbort&&e.onAbort(m),se(m="Aborted("+m+")"),Ce=!0,ze=1,m+=". Build with -sASSERTIONS for more info.";var _=new WebAssembly.RuntimeError(m);throw Ae(_),_}var me;function Se(m){return m.startsWith("data:application/octet-stream;base64,")}function et(m){return m.startsWith("file://")}function mt(m){try{if(m==me&&ye)return new Uint8Array(ye);if(ce)return ce(m);throw"both async and sync fetching of the wasm failed"}catch(_){Ue(_)}}Se(me="tfjs-backend-wasm-threaded-simd.wasm")||(me=Et(me));var ft={};function je(m){this.name="ExitStatus",this.message="Program terminated with exit("+m+")",this.status=m}function ht(m){var _=T.pthreads[m];(function Xn(m,_){m||Ue(_)})(_),T.returnWorkerToPool(_)}function aa(m){var _=T.getNewWorker();if(!_)return 6;T.runningWorkers.push(_),T.pthreads[m.pthread_ptr]=_,_.pthread_ptr=m.pthread_ptr;var x={cmd:"run",start_routine:m.startRoutine,arg:m.arg,pthread_ptr:m.pthread_ptr};return _.runPthread=()=>{de&&_.ref(),_.postMessage(x,m.transferList),delete _.runPthread},_.loaded&&_.runPthread(),0}function tn(m){if(ee)return Be(1,1,m);ze=m,Ge()||(T.terminateAllThreads(),e.onExit&&e.onExit(m),Ce=!0),xe(m,new je(m))}var nn=function ra(m,_){if(ze=m,!_&&ee)throw bt(m),"unwind";tn(m)},T={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){ee?T.initWorker():T.initMainThread()},initMainThread:function(){for(var m=8;m--;)T.allocateUnusedWorker()},initWorker:function(){Lt=!1},setExitStatus:function(m){ze=m},terminateAllThreads:function(){for(var m of Object.values(T.pthreads))T.returnWorkerToPool(m);for(var m of T.unusedWorkers)m.terminate();T.unusedWorkers=[]},returnWorkerToPool:function(m){var _=m.pthread_ptr;delete T.pthreads[_],T.unusedWorkers.push(m),T.runningWorkers.splice(T.runningWorkers.indexOf(m),1),m.pthread_ptr=0,de&&m.unref(),Ur(_)},receiveObjectTransfer:function(m){},threadInitTLS:function(){T.tlsInitFunctions.forEach(m=>m())},loadWasmModuleToWorker:function(m,_){m.onmessage=P=>{var D=P.data,F=D.cmd;if(m.pthread_ptr&&(T.currentProxiedOperationCallerThread=m.pthread_ptr),D.targetThread&&D.targetThread!=On()){var Q=T.pthreads[D.targetThread];return Q?Q.postMessage(D,D.transferList):se('Internal error! Worker sent a message "'+F+'" to target pthread '+D.targetThread+", but that thread no longer exists!"),void(T.currentProxiedOperationCallerThread=void 0)}"processProxyingQueue"===F?yt(D.queue):"spawnThread"===F?aa(D):"cleanupThread"===F?ht(D.thread):"killThread"===F?function en(m){var _=T.pthreads[m];delete T.pthreads[m],_.terminate(),Ur(m),T.runningWorkers.splice(T.runningWorkers.indexOf(_),1),_.pthread_ptr=0}(D.thread):"cancelThread"===F?function na(m){T.pthreads[m].postMessage({cmd:"cancel"})}(D.thread):"loaded"===F?(m.loaded=!0,de&&m.unref(),_&&_(m),m.runPthread&&m.runPthread()):"print"===F?ct("Thread "+D.threadId+": "+D.text):"printErr"===F?se("Thread "+D.threadId+": "+D.text):"alert"===F?alert("Thread "+D.threadId+": "+D.text):"setimmediate"===D.target?m.postMessage(D):"callHandler"===F?e[D.handler](...D.args):F&&se("worker sent an unknown command "+F),T.currentProxiedOperationCallerThread=void 0},m.onerror=P=>{throw se("worker sent an error! "+P.filename+":"+P.lineno+": "+P.message),P},de&&(m.on("message",function(P){m.onmessage({data:P})}),m.on("error",function(P){m.onerror(P)}),m.on("detachedExit",function(){}));var x=[];for(var E of["onExit","onAbort","print","printErr"])e.hasOwnProperty(E)&&x.push(E);m.postMessage({cmd:"load",handlers:x,urlOrBlob:e.mainScriptUrlOrBlob||B,wasmMemory:j,wasmModule:pt})},allocateUnusedWorker:function(){var m,_=Et("tfjs-backend-wasm-threaded-simd.worker.js");m=new Worker(_),T.unusedWorkers.push(m)},getNewWorker:function(){return 0==T.unusedWorkers.length&&(T.allocateUnusedWorker(),T.loadWasmModuleToWorker(T.unusedWorkers[0])),T.unusedWorkers.pop()}};function _t(m){for(;m.length>0;)m.shift()(e)}function bt(m){if(ee)return Be(2,0,m);try{nn(m)}catch(_){!function an(m){if(m instanceof je||"unwind"==m)return ze;xe(1,m)}(_)}}e.PThread=T,e.establishStackSpace=function sa(){var m=On(),_=ke()[m+52>>>2],x=ke()[m+56>>>2];Cs(_,_-x),Ln(_)};var vt,tt=[];function sn(m,_,x,R){return ee?Be(3,1,m,_,x,R):on(m,_,x,R)}function on(m,_,x,R){if(typeof SharedArrayBuffer>"u")return se("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var E=[];if(ee&&0===E.length)return sn(m,_,x,R);var D={startRoutine:x,pthread_ptr:m,arg:R,transferList:E};return ee?(D.cmd="spawnThread",postMessage(D,E),0):aa(D)}function yt(m){Atomics.store(ke(),m>>2,1),On()&&xs(m),Atomics.compareExchange(ke(),m>>2,1,0)}function Ze(m){Ze.shown||(Ze.shown={}),Ze.shown[m]||(Ze.shown[m]=1,de&&(m="warning: "+m),se(m))}function Be(m,_){var x=arguments.length-2,R=arguments;return function _a(m){var _=jr(),x=m();return Ln(_),x}(()=>{for(var E=x,P=Wn(8*E),D=P>>3,F=0;F<x;F++){var Q=R[2+F];st()[D+F>>>0]=Q}return Ms(m,E,P,_)})}e.invokeEntryPoint=function ua(m,_){var x=function oa(m){var _=tt[m];return _||(m>=tt.length&&(tt.length=m+1),tt[m]=_=Pe.get(m)),_}(m)(_);Ge()?T.setExitStatus(x):Ds(x)},e.executeNotifiedProxyingQueue=yt,vt=de?()=>{var m=process.hrtime();return 1e3*m[0]+m[1]/1e6}:()=>performance.timeOrigin+performance.now();var St=[];function ba(m){try{return j.grow(m-oe.byteLength+65535>>>16),pe(j.buffer),1}catch{}}function wt(m){return ee?Be(4,1,m):52}function mn(m,_,x,R,E){return ee?Be(5,1,m,_,x,R,E):70}var va=[null,[],[]];function Sa(m,_){var x=va[m];0===_||10===_?((1===m?ct:se)(Wt(x,0)),x.length=0):x.push(_)}function kt(m,_,x,R){if(ee)return Be(6,1,m,_,x,R);for(var E=0,P=0;P<x;P++){var D=O()[_>>>2],F=O()[_+4>>>2];_+=8;for(var Q=0;Q<F;Q++)Sa(m,Te()[D+Q>>>0]);E+=F}return O()[R>>>2]=E,0}function fn(m){return e["_"+m]}function ka(m,_,x,R,E){var P={string:ge=>{var $e=0;if(null!=ge&&0!==ge){var Ts=1+(ge.length<<2);!function Vt(m,_,x){(function zt(m,_,x,R){if(!(R>0))return 0;for(var E=x>>>=0,P=x+R-1,D=0;D<m.length;++D){var F=m.charCodeAt(D);if(F>=55296&&F<=57343&&(F=65536+((1023&F)<<10)|1023&m.charCodeAt(++D)),F<=127){if(x>=P)break;_[x++>>>0]=F}else if(F<=2047){if(x+1>=P)break;_[x++>>>0]=192|F>>6,_[x++>>>0]=128|63&F}else if(F<=65535){if(x+2>=P)break;_[x++>>>0]=224|F>>12,_[x++>>>0]=128|F>>6&63,_[x++>>>0]=128|63&F}else{if(x+3>=P)break;_[x++>>>0]=240|F>>18,_[x++>>>0]=128|F>>12&63,_[x++>>>0]=128|F>>6&63,_[x++>>>0]=128|63&F}}_[x>>>0]=0})(m,Te(),_,x)}(ge,$e=Wn(Ts),Ts)}return $e},array:ge=>{var $e=Wn(ge.length);return function wa(m,_){(function t(){return j.buffer!=oe&&pe(j.buffer),Gt})().set(m,_>>>0)}(ge,$e),$e}},F=fn(m),Q=[],be=0;if(R)for(var Le=0;Le<R.length;Le++){var Rs=P[x[Le]];Rs?(0===be&&(be=jr()),Q[Le]=Rs(R[Le])):Q[Le]=R[Le]}var $r=F.apply(null,Q);return function eo(ge){return 0!==be&&Ln(be),function D(ge){return"string"===_?function Ht(m,_){return(m>>>=0)?Wt(Te(),m,_):""}(ge):"boolean"===_?!!ge:ge}(ge)}($r)}T.init();var Hn,qr,zn,Ma=[null,tn,bt,sn,wt,mn,kt],gn={__emscripten_init_main_thread_js:function ia(m){ks(m,!De,1,!Ie),T.threadInitTLS()},__emscripten_thread_cleanup:function da(m){ee?postMessage({cmd:"cleanupThread",thread:m}):ht(m)},__pthread_create_js:on,_emscripten_default_pthread_stack_size:function ca(){return 65536},_emscripten_get_now_is_monotonic:function dn(){return!0},_emscripten_notify_task_queue:function pa(m,_,x,R){if(m==_)setTimeout(()=>yt(R));else if(ee)postMessage({targetThread:m,cmd:"processProxyingQueue",queue:R});else{var E=T.pthreads[m];if(!E)return;E.postMessage({cmd:"processProxyingQueue",queue:R})}return 1},_emscripten_set_offscreencanvas_size:function la(m,_,x){return-1},abort:function cn(){Ue("")},emscripten_check_blocking_allowed:function ma(){de||De||Ze("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")},emscripten_date_now:function fa(){return Date.now()},emscripten_get_heap_max:function ha(){return 4294901760},emscripten_get_now:vt,emscripten_memcpy_big:function ga(m,_,x){Te().copyWithin(m>>>0,_>>>0,_+x>>>0)},emscripten_num_logical_cores:function pn(){return de?Y(8074).cpus().length:navigator.hardwareConcurrency},emscripten_receive_on_main_thread_js:function ln(m,_,x){St.length=_;for(var R=x>>3,E=0;E<_;E++)St[E]=st()[R+E>>>0];return(m<0?ft[-m-1]:Ma[m]).apply(null,St)},emscripten_resize_heap:function ya(m){var _=Te().length;if((m>>>=0)<=_)return!1;var Q,x=4294901760;if(m>x)return!1;for(var E=1;E<=4;E*=2){var P=_*(1+.2/E);if(P=Math.min(P,m+100663296),ba(Math.min(x,(Q=Math.max(m,P))+(65536-Q%65536)%65536)))return!0}return!1},emscripten_unwind_to_js_event_loop:function Ia(){throw"unwind"},exit:nn,fd_close:wt,fd_seek:mn,fd_write:kt,memory:j||e.wasmMemory},On=(function ta(){var m={env:gn,wasi_snapshot_preview1:gn};function _(D,F){if(e.asm=D.exports,function rn(m){T.tlsInitFunctions.push(m)}(e.asm._emscripten_tls_init),Pe=e.asm.__indirect_function_table,function Jn(m){Jt.unshift(m)}(e.asm.__wasm_call_ctors),pt=F,!ee){var be=T.unusedWorkers.length;T.unusedWorkers.forEach(function(Le){T.loadWasmModuleToWorker(Le,function(){--be||function Yt(){if(Ee--,e.monitorRunDependencies&&e.monitorRunDependencies(Ee),0==Ee&&(null!==Ye&&(clearInterval(Ye),Ye=null),Re)){var _=Re;Re=null,_()}}()})})}}function x(D){_(D.instance,D.module)}function R(D){return function ea(){if(!ye&&(Ie||De)){if("function"==typeof fetch&&!et(me))return fetch(me,{credentials:"same-origin"}).then(function(m){if(!m.ok)throw"failed to load wasm binary file at '"+me+"'";return m.arrayBuffer()}).catch(function(){return mt(me)});if(ut)return new Promise(function(m,_){ut(me,function(x){m(new Uint8Array(x))},_)})}return Promise.resolve().then(function(){return mt(me)})}().then(function(F){return WebAssembly.instantiate(F,m)}).then(function(F){return F}).then(D,function(F){se("failed to asynchronously prepare wasm: "+F),Ue(F)})}if(ee||function as(){Ee++,e.monitorRunDependencies&&e.monitorRunDependencies(Ee)}(),e.instantiateWasm)try{return e.instantiateWasm(m,_)}catch(D){se("Module.instantiateWasm callback failed with error: "+D),Ae(D)}(function E(){return ye||"function"!=typeof WebAssembly.instantiateStreaming||Se(me)||et(me)||de||"function"!=typeof fetch?R(x):fetch(me,{credentials:"same-origin"}).then(function(D){return WebAssembly.instantiateStreaming(D,m).then(x,function(Q){return se("wasm streaming compile failed: "+Q),se("falling back to ArrayBuffer instantiation"),R(x)})})})().catch(Ae)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.__wasm_call_ctors).apply(null,arguments)},e._init=function(){return(e._init=e.asm.init).apply(null,arguments)},e._init_with_threads_count=function(){return(e._init_with_threads_count=e.asm.init_with_threads_count).apply(null,arguments)},e._get_threads_count=function(){return(e._get_threads_count=e.asm.get_threads_count).apply(null,arguments)},e._register_tensor=function(){return(e._register_tensor=e.asm.register_tensor).apply(null,arguments)},e._dispose_data=function(){return(e._dispose_data=e.asm.dispose_data).apply(null,arguments)},e._dispose=function(){return(e._dispose=e.asm.dispose).apply(null,arguments)},e._Abs=function(){return(e._Abs=e.asm.Abs).apply(null,arguments)},e._Acos=function(){return(e._Acos=e.asm.Acos).apply(null,arguments)},e._Acosh=function(){return(e._Acosh=e.asm.Acosh).apply(null,arguments)},e._Add=function(){return(e._Add=e.asm.Add).apply(null,arguments)},e._AddN=function(){return(e._AddN=e.asm.AddN).apply(null,arguments)},e._All=function(){return(e._All=e.asm.All).apply(null,arguments)},e._Any=function(){return(e._Any=e.asm.Any).apply(null,arguments)},e._ArgMax=function(){return(e._ArgMax=e.asm.ArgMax).apply(null,arguments)},e._ArgMin=function(){return(e._ArgMin=e.asm.ArgMin).apply(null,arguments)},e._Asin=function(){return(e._Asin=e.asm.Asin).apply(null,arguments)},e._Asinh=function(){return(e._Asinh=e.asm.Asinh).apply(null,arguments)},e._Atan=function(){return(e._Atan=e.asm.Atan).apply(null,arguments)},e._Atan2=function(){return(e._Atan2=e.asm.Atan2).apply(null,arguments)},e._Atanh=function(){return(e._Atanh=e.asm.Atanh).apply(null,arguments)},e._AvgPool=function(){return(e._AvgPool=e.asm.AvgPool).apply(null,arguments)},e._AvgPool3D=function(){return(e._AvgPool3D=e.asm.AvgPool3D).apply(null,arguments)},e._AvgPool3DGrad=function(){return(e._AvgPool3DGrad=e.asm.AvgPool3DGrad).apply(null,arguments)},e._AvgPoolGrad=function(){return(e._AvgPoolGrad=e.asm.AvgPoolGrad).apply(null,arguments)},e._BatchMatMul=function(){return(e._BatchMatMul=e.asm.BatchMatMul).apply(null,arguments)},e._Bincount=function(){return(e._Bincount=e.asm.Bincount).apply(null,arguments)},e._BitwiseAnd=function(){return(e._BitwiseAnd=e.asm.BitwiseAnd).apply(null,arguments)},e._Ceil=function(){return(e._Ceil=e.asm.Ceil).apply(null,arguments)},e._ClipByValue=function(){return(e._ClipByValue=e.asm.ClipByValue).apply(null,arguments)},e._Conv2D=function(){return(e._Conv2D=e.asm.Conv2D).apply(null,arguments)},e._Conv2DBackpropInput=function(){return(e._Conv2DBackpropInput=e.asm.Conv2DBackpropInput).apply(null,arguments)},e._Conv3D=function(){return(e._Conv3D=e.asm.Conv3D).apply(null,arguments)},e._Conv3DBackpropFilterV2=function(){return(e._Conv3DBackpropFilterV2=e.asm.Conv3DBackpropFilterV2).apply(null,arguments)},e._Conv3DBackpropInputV2=function(){return(e._Conv3DBackpropInputV2=e.asm.Conv3DBackpropInputV2).apply(null,arguments)},e._Cos=function(){return(e._Cos=e.asm.Cos).apply(null,arguments)},e._Cosh=function(){return(e._Cosh=e.asm.Cosh).apply(null,arguments)},e._CropAndResize=function(){return(e._CropAndResize=e.asm.CropAndResize).apply(null,arguments)},e._Cumprod=function(){return(e._Cumprod=e.asm.Cumprod).apply(null,arguments)},e._Cumsum=function(){return(e._Cumsum=e.asm.Cumsum).apply(null,arguments)},e._DenseBincount=function(){return(e._DenseBincount=e.asm.DenseBincount).apply(null,arguments)},e._DepthToSpace=function(){return(e._DepthToSpace=e.asm.DepthToSpace).apply(null,arguments)},e._DepthwiseConv2dNative=function(){return(e._DepthwiseConv2dNative=e.asm.DepthwiseConv2dNative).apply(null,arguments)},e._Diag=function(){return(e._Diag=e.asm.Diag).apply(null,arguments)},e._Dilation2D=function(){return(e._Dilation2D=e.asm.Dilation2D).apply(null,arguments)},e._Dilation2DBackpropFilter=function(){return(e._Dilation2DBackpropFilter=e.asm.Dilation2DBackpropFilter).apply(null,arguments)},e._Dilation2DBackpropInput=function(){return(e._Dilation2DBackpropInput=e.asm.Dilation2DBackpropInput).apply(null,arguments)},e._Elu=function(){return(e._Elu=e.asm.Elu).apply(null,arguments)},e._EluGrad=function(){return(e._EluGrad=e.asm.EluGrad).apply(null,arguments)},e._Equal=function(){return(e._Equal=e.asm.Equal).apply(null,arguments)},e._Erf=function(){return(e._Erf=e.asm.Erf).apply(null,arguments)},e._Exp=function(){return(e._Exp=e.asm.Exp).apply(null,arguments)},e._Expm1=function(){return(e._Expm1=e.asm.Expm1).apply(null,arguments)},e._FlipLeftRight=function(){return(e._FlipLeftRight=e.asm.FlipLeftRight).apply(null,arguments)},e._Floor=function(){return(e._Floor=e.asm.Floor).apply(null,arguments)},e._FloorDiv=function(){return(e._FloorDiv=e.asm.FloorDiv).apply(null,arguments)},e._FusedBatchNorm=function(){return(e._FusedBatchNorm=e.asm.FusedBatchNorm).apply(null,arguments)},e._FusedConv2D=function(){return(e._FusedConv2D=e.asm.FusedConv2D).apply(null,arguments)},e._FusedDepthwiseConv2D=function(){return(e._FusedDepthwiseConv2D=e.asm.FusedDepthwiseConv2D).apply(null,arguments)},e._Gather=function(){return(e._Gather=e.asm.Gather).apply(null,arguments)},e._GatherNd=function(){return(e._GatherNd=e.asm.GatherNd).apply(null,arguments)},e._Greater=function(){return(e._Greater=e.asm.Greater).apply(null,arguments)},e._GreaterEqual=function(){return(e._GreaterEqual=e.asm.GreaterEqual).apply(null,arguments)},e._IsFinite=function(){return(e._IsFinite=e.asm.IsFinite).apply(null,arguments)},e._IsInf=function(){return(e._IsInf=e.asm.IsInf).apply(null,arguments)},e._IsNan=function(){return(e._IsNan=e.asm.IsNan).apply(null,arguments)},e._LRN=function(){return(e._LRN=e.asm.LRN).apply(null,arguments)},e._LRNGrad=function(){return(e._LRNGrad=e.asm.LRNGrad).apply(null,arguments)},e._LeakyRelu=function(){return(e._LeakyRelu=e.asm.LeakyRelu).apply(null,arguments)},e._Less=function(){return(e._Less=e.asm.Less).apply(null,arguments)},e._LessEqual=function(){return(e._LessEqual=e.asm.LessEqual).apply(null,arguments)},e._LinSpace=function(){return(e._LinSpace=e.asm.LinSpace).apply(null,arguments)},e._Log=function(){return(e._Log=e.asm.Log).apply(null,arguments)},e._Log1p=function(){return(e._Log1p=e.asm.Log1p).apply(null,arguments)},e._LogicalAnd=function(){return(e._LogicalAnd=e.asm.LogicalAnd).apply(null,arguments)},e._LogicalNot=function(){return(e._LogicalNot=e.asm.LogicalNot).apply(null,arguments)},e._LogicalOr=function(){return(e._LogicalOr=e.asm.LogicalOr).apply(null,arguments)},e._LogicalXor=function(){return(e._LogicalXor=e.asm.LogicalXor).apply(null,arguments)},e._Max=function(){return(e._Max=e.asm.Max).apply(null,arguments)},e._MaxPool=function(){return(e._MaxPool=e.asm.MaxPool).apply(null,arguments)},e._MaxPool3D=function(){return(e._MaxPool3D=e.asm.MaxPool3D).apply(null,arguments)},e._MaxPool3DGrad=function(){return(e._MaxPool3DGrad=e.asm.MaxPool3DGrad).apply(null,arguments)},e._MaxPoolGrad=function(){return(e._MaxPoolGrad=e.asm.MaxPoolGrad).apply(null,arguments)},e._MaxPoolWithArgmax=function(){return(e._MaxPoolWithArgmax=e.asm.MaxPoolWithArgmax).apply(null,arguments)},e._Maximum=function(){return(e._Maximum=e.asm.Maximum).apply(null,arguments)},e._Mean=function(){return(e._Mean=e.asm.Mean).apply(null,arguments)},e._Min=function(){return(e._Min=e.asm.Min).apply(null,arguments)},e._Minimum=function(){return(e._Minimum=e.asm.Minimum).apply(null,arguments)},e._MirrorPad=function(){return(e._MirrorPad=e.asm.MirrorPad).apply(null,arguments)},e._Mod=function(){return(e._Mod=e.asm.Mod).apply(null,arguments)},e._Multinomial=function(){return(e._Multinomial=e.asm.Multinomial).apply(null,arguments)},e._Multiply=function(){return(e._Multiply=e.asm.Multiply).apply(null,arguments)},e._Neg=function(){return(e._Neg=e.asm.Neg).apply(null,arguments)},e._NonMaxSuppressionV3=function(){return(e._NonMaxSuppressionV3=e.asm.NonMaxSuppressionV3).apply(null,arguments)},e._NonMaxSuppressionV4=function(){return(e._NonMaxSuppressionV4=e.asm.NonMaxSuppressionV4).apply(null,arguments)},e._NonMaxSuppressionV5=function(){return(e._NonMaxSuppressionV5=e.asm.NonMaxSuppressionV5).apply(null,arguments)},e._NotEqual=function(){return(e._NotEqual=e.asm.NotEqual).apply(null,arguments)},e._OneHot=function(){return(e._OneHot=e.asm.OneHot).apply(null,arguments)},e._PadV2=function(){return(e._PadV2=e.asm.PadV2).apply(null,arguments)},e._Pow=function(){return(e._Pow=e.asm.Pow).apply(null,arguments)},e._Prelu=function(){return(e._Prelu=e.asm.Prelu).apply(null,arguments)},e._Prod=function(){return(e._Prod=e.asm.Prod).apply(null,arguments)},e._RealDiv=function(){return(e._RealDiv=e.asm.RealDiv).apply(null,arguments)},e._Reciprocal=function(){return(e._Reciprocal=e.asm.Reciprocal).apply(null,arguments)},e._Relu=function(){return(e._Relu=e.asm.Relu).apply(null,arguments)},e._Relu6=function(){return(e._Relu6=e.asm.Relu6).apply(null,arguments)},e._ResizeBilinear=function(){return(e._ResizeBilinear=e.asm.ResizeBilinear).apply(null,arguments)},e._ResizeBilinearGrad=function(){return(e._ResizeBilinearGrad=e.asm.ResizeBilinearGrad).apply(null,arguments)},e._ResizeNearestNeighbor=function(){return(e._ResizeNearestNeighbor=e.asm.ResizeNearestNeighbor).apply(null,arguments)},e._ResizeNearestNeighborGrad=function(){return(e._ResizeNearestNeighborGrad=e.asm.ResizeNearestNeighborGrad).apply(null,arguments)},e._Reverse=function(){return(e._Reverse=e.asm.Reverse).apply(null,arguments)},e._RotateWithOffset=function(){return(e._RotateWithOffset=e.asm.RotateWithOffset).apply(null,arguments)},e._Round=function(){return(e._Round=e.asm.Round).apply(null,arguments)},e._Rsqrt=function(){return(e._Rsqrt=e.asm.Rsqrt).apply(null,arguments)},e._ScatterNd=function(){return(e._ScatterNd=e.asm.ScatterNd).apply(null,arguments)},e._SearchSorted=function(){return(e._SearchSorted=e.asm.SearchSorted).apply(null,arguments)},e._SelectV2=function(){return(e._SelectV2=e.asm.SelectV2).apply(null,arguments)},e._Selu=function(){return(e._Selu=e.asm.Selu).apply(null,arguments)},e._Sigmoid=function(){return(e._Sigmoid=e.asm.Sigmoid).apply(null,arguments)},e._Sign=function(){return(e._Sign=e.asm.Sign).apply(null,arguments)},e._Sin=function(){return(e._Sin=e.asm.Sin).apply(null,arguments)},e._Sinh=function(){return(e._Sinh=e.asm.Sinh).apply(null,arguments)},e._Softmax=function(){return(e._Softmax=e.asm.Softmax).apply(null,arguments)},e._Softplus=function(){return(e._Softplus=e.asm.Softplus).apply(null,arguments)},e._SparseFillEmptyRows=function(){return(e._SparseFillEmptyRows=e.asm.SparseFillEmptyRows).apply(null,arguments)},e._SparseReshape=function(){return(e._SparseReshape=e.asm.SparseReshape).apply(null,arguments)},e._SparseSegmentReduction=function(){return(e._SparseSegmentReduction=e.asm.SparseSegmentReduction).apply(null,arguments)},e._SparseToDense=function(){return(e._SparseToDense=e.asm.SparseToDense).apply(null,arguments)},e._Sqrt=function(){return(e._Sqrt=e.asm.Sqrt).apply(null,arguments)},e._Square=function(){return(e._Square=e.asm.Square).apply(null,arguments)},e._SquaredDifference=function(){return(e._SquaredDifference=e.asm.SquaredDifference).apply(null,arguments)},e._Step=function(){return(e._Step=e.asm.Step).apply(null,arguments)},e._StridedSlice=function(){return(e._StridedSlice=e.asm.StridedSlice).apply(null,arguments)},e._Sub=function(){return(e._Sub=e.asm.Sub).apply(null,arguments)},e._Sum=function(){return(e._Sum=e.asm.Sum).apply(null,arguments)},e._Tan=function(){return(e._Tan=e.asm.Tan).apply(null,arguments)},e._Tanh=function(){return(e._Tanh=e.asm.Tanh).apply(null,arguments)},e._TensorScatterUpdate=function(){return(e._TensorScatterUpdate=e.asm.TensorScatterUpdate).apply(null,arguments)},e._Tile=function(){return(e._Tile=e.asm.Tile).apply(null,arguments)},e._TopK=function(){return(e._TopK=e.asm.TopK).apply(null,arguments)},e._Transform=function(){return(e._Transform=e.asm.Transform).apply(null,arguments)},e._Transpose=function(){return(e._Transpose=e.asm.Transpose).apply(null,arguments)},e.__FusedMatMul=function(){return(e.__FusedMatMul=e.asm._FusedMatMul).apply(null,arguments)},e._malloc=function(){return(e._malloc=e.asm.malloc).apply(null,arguments)},e._free=function(){return(e._free=e.asm.free).apply(null,arguments)},e.__emscripten_tls_init=function(){return(e.__emscripten_tls_init=e.asm._emscripten_tls_init).apply(null,arguments)},e._pthread_self=function(){return(On=e._pthread_self=e.asm.pthread_self).apply(null,arguments)}),ks=(e.___errno_location=function(){return(e.___errno_location=e.asm.__errno_location).apply(null,arguments)},e.__emscripten_thread_init=function(){return(ks=e.__emscripten_thread_init=e.asm._emscripten_thread_init).apply(null,arguments)}),Ms=(e.__emscripten_thread_crashed=function(){return(e.__emscripten_thread_crashed=e.asm._emscripten_thread_crashed).apply(null,arguments)},e._emscripten_main_thread_process_queued_calls=function(){return(e._emscripten_main_thread_process_queued_calls=e.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},e._emscripten_main_browser_thread_id=function(){return(e._emscripten_main_browser_thread_id=e.asm.emscripten_main_browser_thread_id).apply(null,arguments)},e._emscripten_run_in_main_runtime_thread_js=function(){return(Ms=e._emscripten_run_in_main_runtime_thread_js=e.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)}),xs=(e._emscripten_dispatch_to_thread_=function(){return(e._emscripten_dispatch_to_thread_=e.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},e.__emscripten_proxy_execute_task_queue=function(){return(xs=e.__emscripten_proxy_execute_task_queue=e.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)}),Ur=e.__emscripten_thread_free_data=function(){return(Ur=e.__emscripten_thread_free_data=e.asm._emscripten_thread_free_data).apply(null,arguments)},Ds=e.__emscripten_thread_exit=function(){return(Ds=e.__emscripten_thread_exit=e.asm._emscripten_thread_exit).apply(null,arguments)},Cs=e._emscripten_stack_set_limits=function(){return(Cs=e._emscripten_stack_set_limits=e.asm.emscripten_stack_set_limits).apply(null,arguments)},jr=e.stackSave=function(){return(jr=e.stackSave=e.asm.stackSave).apply(null,arguments)},Ln=e.stackRestore=function(){return(Ln=e.stackRestore=e.asm.stackRestore).apply(null,arguments)},Wn=e.stackAlloc=function(){return(Wn=e.stackAlloc=e.asm.stackAlloc).apply(null,arguments)};function Zr(m){if(m=m||ot,!(Ee>0)){if(ee)return Z(e),le(),void startWorker(e);(function Qe(){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)m=e.preRun.shift(),Kt.unshift(m);var m;_t(Kt)})(),Ee>0||(e.setStatus?(e.setStatus("Running..."),setTimeout(function(){setTimeout(function(){e.setStatus("")},1),_()},1)):_())}function _(){Hn||(Hn=!0,e.calledRun=!0,!Ce&&(le(),Z(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),function Qt(){if(!ee){if(e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;)m=e.postRun.shift(),Fe.unshift(m);_t(Fe)}var m}()))}}if(e.dynCall_iijjiiii=function(){return(e.dynCall_iijjiiii=e.asm.dynCall_iijjiiii).apply(null,arguments)},e.dynCall_jiji=function(){return(e.dynCall_jiji=e.asm.dynCall_jiji).apply(null,arguments)},e.keepRuntimeAlive=Ge,e.wasmMemory=j,e.cwrap=function hn(m,_,x,R){var E=(x=x||[]).every(D=>"number"===D||"boolean"===D);return"string"!==_&&E&&!R?fn(m):function(){return ka(m,_,x,arguments)}},e.ExitStatus=je,e.PThread=T,Re=function m(){Hn||Zr(),Hn||(Re=m)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);e.preInit.length>0;)e.preInit.pop()();if(Zr(),We&&(qr={uncaughtException:process.listeners("uncaughtException").filter(function(m){return!We.uncaughtException.indexOf(m)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(m){return!We.unhandledRejection.indexOf(m)>-1})}),typeof WasmBackendModule<"u")zn=WasmBackendModule;else{if(!(typeof re<"u"))throw new Error("Could not find wasm module in post.js");zn=re}if(qr){var Ns=zn._dispose;zn._dispose=function(){Ns(),qr.uncaughtException.forEach(function(m){process.removeListener("uncaughtException",m)}),qr.unhandledRejection.forEach(function(m){process.removeListener("unhandledRejection",m)})}}return re.ready});Tt.exports=o},74466:Tt=>{Tt.exports.$='"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};'},94732:(Tt,ts,Y)=>{var B,o=(B=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0,typeof __filename<"u"&&(B=B||__filename),function(re){var Te,rt,ke,t=typeof(re=re||{})<"u"?re:{};t.ready=new Promise(function(I,M){Te=I,rt=M}),typeof process<"u"&&process.listeners&&(ke={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var Ke,xe,Ie,O=Object.assign({},t),Pt=[],Z="object"==typeof window,Ae="function"==typeof importScripts,We="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,ie="";if(We){var ee=Y(9893),J=Y(45281);ie=Ae?J.dirname(ie)+"/":__dirname+"/",Ke=(I,M)=>(I=Qe(I)?new URL(I):J.normalize(I),ee.readFileSync(I,M?void 0:"utf8")),Ie=I=>{var M=Ke(I,!0);return M.buffer||(M=new Uint8Array(M)),M},xe=(I,M,N)=>{I=Qe(I)?new URL(I):J.normalize(I),ee.readFile(I,function(V,q){V?N(V):M(q.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),Pt=process.argv.slice(2),process.on("uncaughtException",function(I){if(!(I instanceof Ye))throw I}),process.on("unhandledRejection",function(I){throw I}),t.inspect=function(){return"[Emscripten Module object]"}}else(Z||Ae)&&(Ae?ie=self.location.href:typeof document<"u"&&document.currentScript&&(ie=document.currentScript.src),B&&(ie=B),ie=0!==ie.indexOf("blob:")?ie.substr(0,ie.replace(/[?#].*/,"").lastIndexOf("/")+1):"",Ke=I=>{var M=new XMLHttpRequest;return M.open("GET",I,!1),M.send(null),M.responseText},Ae&&(Ie=I=>{var M=new XMLHttpRequest;return M.open("GET",I,!1),M.responseType="arraybuffer",M.send(null),new Uint8Array(M.response)}),xe=(I,M,N)=>{var V=new XMLHttpRequest;V.open("GET",I,!0),V.responseType="arraybuffer",V.onload=()=>{200==V.status||0==V.status&&V.response?M(V.response):N()},V.onerror=N,V.send(null)});var ce,Et=t.print||console.log.bind(console),ve=t.printErr||console.warn.bind(console);Object.assign(t,O),O=null,t.arguments&&(Pt=t.arguments),t.wasmBinary&&(ce=t.wasmBinary),"object"!=typeof WebAssembly&&Fe("no native wasm support detected");var Je,qn,$n,ye,Ce,He=!1,dt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function ct(I,M,N){for(var V=(M>>>=0)+N,q=M;I[q]&&!(q>=V);)++q;if(q-M>16&&I.buffer&&dt)return dt.decode(I.subarray(M,q));for(var $="";M<q;){var L=I[M++];if(128&L){var W=63&I[M++];if(192!=(224&L)){var te=63&I[M++];if((L=224==(240&L)?(15&L)<<12|W<<6|te:(7&L)<<18|W<<12|te<<6|63&I[M++])<65536)$+=String.fromCharCode(L);else{var _e=L-65536;$+=String.fromCharCode(55296|_e>>10,56320|1023&_e)}}else $+=String.fromCharCode((31&L)<<6|W)}else $+=String.fromCharCode(L)}return $}function lt(I){qn=I,t.HEAP8=$n=new Int8Array(I),t.HEAP16=new Int16Array(I),t.HEAP32=new Int32Array(I),t.HEAPU8=ye=new Uint8Array(I),t.HEAPU16=new Uint16Array(I),t.HEAPU32=Ce=new Uint32Array(I),t.HEAPF32=new Float32Array(I),t.HEAPF64=new Float64Array(I)}var zt=[],Vt=[],oe=[],pe=0,Ve=null,Pe=null;function Fe(I){t.onAbort&&t.onAbort(I),ve(I="Aborted("+I+")"),He=!0,I+=". Build with -sASSERTIONS for more info.";var M=new WebAssembly.RuntimeError(I);throw rt(M),M}var le;function Ge(I){return I.startsWith("data:application/octet-stream;base64,")}function Qe(I){return I.startsWith("file://")}function Qt(I){try{if(I==le&&ce)return new Uint8Array(ce);if(Ie)return Ie(I);throw"both async and sync fetching of the wasm failed"}catch(M){Fe(M)}}function Ye(I){this.name="ExitStatus",this.message="Program terminated with exit("+I+")",this.status=I}function Re(I){for(;I.length>0;)I.shift()(t)}function Se(I){try{return Je.grow(I-qn.byteLength+65535>>>16),lt(Je.buffer),1}catch{}}Ge(le="tfjs-backend-wasm.wasm")||(le=function ot(I){return t.locateFile?t.locateFile(I,ie):ie+I}(le));var ta=[null,[],[]];function rs(I,M){var N=ta[I];0===M||10===M?((1===I?Et:ve)(ct(N,0)),N.length=0):N.push(M)}function ft(I){return t["_"+I]}function en(I,M,N,V,q){var $={string:fe=>{var Oe=0;if(null!=fe&&0!==fe){var Ct=1+(fe.length<<2);!function ns(I,M,N){(function Zn(I,M,N,V){if(!(V>0))return 0;for(var q=N>>>=0,$=N+V-1,L=0;L<I.length;++L){var W=I.charCodeAt(L);if(W>=55296&&W<=57343&&(W=65536+((1023&W)<<10)|1023&I.charCodeAt(++L)),W<=127){if(N>=$)break;M[N++>>>0]=W}else if(W<=2047){if(N+1>=$)break;M[N++>>>0]=192|W>>6,M[N++>>>0]=128|63&W}else if(W<=65535){if(N+2>=$)break;M[N++>>>0]=224|W>>12,M[N++>>>0]=128|W>>6&63,M[N++>>>0]=128|63&W}else{if(N+3>=$)break;M[N++>>>0]=240|W>>18,M[N++>>>0]=128|W>>12&63,M[N++>>>0]=128|W>>6&63,M[N++>>>0]=128|63&W}}M[N>>>0]=0})(I,ye,M,N)}(fe,Oe=xt(Ct),Ct)}return Oe},array:fe=>{var Oe=xt(fe.length);return function je(I,M){$n.set(I,M>>>0)}(fe,Oe),Oe}},W=ft(I),te=[],_e=0;if(V)for(var Me=0;Me<V.length;Me++){var Bn=$[N[Me]];Bn?(0===_e&&(_e=At()),te[Me]=Bn(V[Me])):te[Me]=V[Me]}var Dt=W.apply(null,te);return function Vr(fe){return 0!==_e&&Tn(_e),function L(fe){return"string"===M?function se(I,M){return(I>>>=0)?ct(ye,I,M):""}(fe):"boolean"===M?!!fe:fe}(fe)}(Dt)}var nt,at,qe,ht={abort:function as(){Fe("")},emscripten_get_heap_max:function Ue(){return 4294901760},emscripten_memcpy_big:function Yn(I,M,N){ye.copyWithin(I>>>0,M>>>0,M+N>>>0)},emscripten_resize_heap:function et(I){var te,M=ye.length,N=4294901760;if((I>>>=0)>N)return!1;for(var q=1;q<=4;q*=2){var $=M*(1+.2/q);if($=Math.min($,I+100663296),Se(Math.min(N,(te=Math.max(I,$))+(65536-te%65536)%65536)))return!0}return!1},fd_close:function mt(I){return 52},fd_seek:function ea(I,M,N,V,q){return 70},fd_write:function ss(I,M,N,V){for(var q=0,$=0;$<N;$++){var L=Ce[M>>>2],W=Ce[M+4>>>2];M+=8;for(var te=0;te<W;te++)rs(I,ye[L+te>>>0]);q+=W}return Ce[V>>>2]=q,0}},At=(function Jn(){var I={env:ht,wasi_snapshot_preview1:ht};function M(L,W){t.asm=L.exports,lt((Je=t.asm.memory).buffer),function Xt(I){Vt.unshift(I)}(t.asm.__wasm_call_ctors),function Jt(){if(pe--,t.monitorRunDependencies&&t.monitorRunDependencies(pe),0==pe&&(null!==Ve&&(clearInterval(Ve),Ve=null),Pe)){var M=Pe;Pe=null,M()}}()}function N(L){M(L.instance)}function V(L){return function Kn(){if(!ce&&(Z||Ae)){if("function"==typeof fetch&&!Qe(le))return fetch(le,{credentials:"same-origin"}).then(function(I){if(!I.ok)throw"failed to load wasm binary file at '"+le+"'";return I.arrayBuffer()}).catch(function(){return Qt(le)});if(xe)return new Promise(function(I,M){xe(le,function(N){I(new Uint8Array(N))},M)})}return Promise.resolve().then(function(){return Qt(le)})}().then(function(W){return WebAssembly.instantiate(W,I)}).then(function(W){return W}).then(L,function(W){ve("failed to asynchronously prepare wasm: "+W),Fe(W)})}if(function Kt(){pe++,t.monitorRunDependencies&&t.monitorRunDependencies(pe)}(),t.instantiateWasm)try{return t.instantiateWasm(I,M)}catch(L){ve("Module.instantiateWasm callback failed with error: "+L),rt(L)}(function q(){return ce||"function"!=typeof WebAssembly.instantiateStreaming||Ge(le)||Qe(le)||We||"function"!=typeof fetch?V(N):fetch(le,{credentials:"same-origin"}).then(function(L){return WebAssembly.instantiateStreaming(L,I).then(N,function(te){return ve("wasm streaming compile failed: "+te),ve("falling back to ArrayBuffer instantiation"),V(N)})})})().catch(rt)}(),t.___wasm_call_ctors=function(){return(t.___wasm_call_ctors=t.asm.__wasm_call_ctors).apply(null,arguments)},t._init=function(){return(t._init=t.asm.init).apply(null,arguments)},t._init_with_threads_count=function(){return(t._init_with_threads_count=t.asm.init_with_threads_count).apply(null,arguments)},t._get_threads_count=function(){return(t._get_threads_count=t.asm.get_threads_count).apply(null,arguments)},t._register_tensor=function(){return(t._register_tensor=t.asm.register_tensor).apply(null,arguments)},t._dispose_data=function(){return(t._dispose_data=t.asm.dispose_data).apply(null,arguments)},t._dispose=function(){return(t._dispose=t.asm.dispose).apply(null,arguments)},t._Abs=function(){return(t._Abs=t.asm.Abs).apply(null,arguments)},t._Acos=function(){return(t._Acos=t.asm.Acos).apply(null,arguments)},t._Acosh=function(){return(t._Acosh=t.asm.Acosh).apply(null,arguments)},t._Add=function(){return(t._Add=t.asm.Add).apply(null,arguments)},t._AddN=function(){return(t._AddN=t.asm.AddN).apply(null,arguments)},t._All=function(){return(t._All=t.asm.All).apply(null,arguments)},t._Any=function(){return(t._Any=t.asm.Any).apply(null,arguments)},t._ArgMax=function(){return(t._ArgMax=t.asm.ArgMax).apply(null,arguments)},t._ArgMin=function(){return(t._ArgMin=t.asm.ArgMin).apply(null,arguments)},t._Asin=function(){return(t._Asin=t.asm.Asin).apply(null,arguments)},t._Asinh=function(){return(t._Asinh=t.asm.Asinh).apply(null,arguments)},t._Atan=function(){return(t._Atan=t.asm.Atan).apply(null,arguments)},t._Atan2=function(){return(t._Atan2=t.asm.Atan2).apply(null,arguments)},t._Atanh=function(){return(t._Atanh=t.asm.Atanh).apply(null,arguments)},t._AvgPool=function(){return(t._AvgPool=t.asm.AvgPool).apply(null,arguments)},t._AvgPool3D=function(){return(t._AvgPool3D=t.asm.AvgPool3D).apply(null,arguments)},t._AvgPool3DGrad=function(){return(t._AvgPool3DGrad=t.asm.AvgPool3DGrad).apply(null,arguments)},t._AvgPoolGrad=function(){return(t._AvgPoolGrad=t.asm.AvgPoolGrad).apply(null,arguments)},t._BatchMatMul=function(){return(t._BatchMatMul=t.asm.BatchMatMul).apply(null,arguments)},t._Bincount=function(){return(t._Bincount=t.asm.Bincount).apply(null,arguments)},t._BitwiseAnd=function(){return(t._BitwiseAnd=t.asm.BitwiseAnd).apply(null,arguments)},t._Ceil=function(){return(t._Ceil=t.asm.Ceil).apply(null,arguments)},t._ClipByValue=function(){return(t._ClipByValue=t.asm.ClipByValue).apply(null,arguments)},t._Conv2D=function(){return(t._Conv2D=t.asm.Conv2D).apply(null,arguments)},t._Conv2DBackpropInput=function(){return(t._Conv2DBackpropInput=t.asm.Conv2DBackpropInput).apply(null,arguments)},t._Conv3D=function(){return(t._Conv3D=t.asm.Conv3D).apply(null,arguments)},t._Conv3DBackpropFilterV2=function(){return(t._Conv3DBackpropFilterV2=t.asm.Conv3DBackpropFilterV2).apply(null,arguments)},t._Conv3DBackpropInputV2=function(){return(t._Conv3DBackpropInputV2=t.asm.Conv3DBackpropInputV2).apply(null,arguments)},t._Cos=function(){return(t._Cos=t.asm.Cos).apply(null,arguments)},t._Cosh=function(){return(t._Cosh=t.asm.Cosh).apply(null,arguments)},t._CropAndResize=function(){return(t._CropAndResize=t.asm.CropAndResize).apply(null,arguments)},t._Cumprod=function(){return(t._Cumprod=t.asm.Cumprod).apply(null,arguments)},t._Cumsum=function(){return(t._Cumsum=t.asm.Cumsum).apply(null,arguments)},t._DenseBincount=function(){return(t._DenseBincount=t.asm.DenseBincount).apply(null,arguments)},t._DepthToSpace=function(){return(t._DepthToSpace=t.asm.DepthToSpace).apply(null,arguments)},t._DepthwiseConv2dNative=function(){return(t._DepthwiseConv2dNative=t.asm.DepthwiseConv2dNative).apply(null,arguments)},t._Diag=function(){return(t._Diag=t.asm.Diag).apply(null,arguments)},t._Dilation2D=function(){return(t._Dilation2D=t.asm.Dilation2D).apply(null,arguments)},t._Dilation2DBackpropFilter=function(){return(t._Dilation2DBackpropFilter=t.asm.Dilation2DBackpropFilter).apply(null,arguments)},t._Dilation2DBackpropInput=function(){return(t._Dilation2DBackpropInput=t.asm.Dilation2DBackpropInput).apply(null,arguments)},t._Elu=function(){return(t._Elu=t.asm.Elu).apply(null,arguments)},t._EluGrad=function(){return(t._EluGrad=t.asm.EluGrad).apply(null,arguments)},t._Equal=function(){return(t._Equal=t.asm.Equal).apply(null,arguments)},t._Erf=function(){return(t._Erf=t.asm.Erf).apply(null,arguments)},t._Exp=function(){return(t._Exp=t.asm.Exp).apply(null,arguments)},t._Expm1=function(){return(t._Expm1=t.asm.Expm1).apply(null,arguments)},t._FlipLeftRight=function(){return(t._FlipLeftRight=t.asm.FlipLeftRight).apply(null,arguments)},t._Floor=function(){return(t._Floor=t.asm.Floor).apply(null,arguments)},t._FloorDiv=function(){return(t._FloorDiv=t.asm.FloorDiv).apply(null,arguments)},t._FusedBatchNorm=function(){return(t._FusedBatchNorm=t.asm.FusedBatchNorm).apply(null,arguments)},t._FusedConv2D=function(){return(t._FusedConv2D=t.asm.FusedConv2D).apply(null,arguments)},t._FusedDepthwiseConv2D=function(){return(t._FusedDepthwiseConv2D=t.asm.FusedDepthwiseConv2D).apply(null,arguments)},t._Gather=function(){return(t._Gather=t.asm.Gather).apply(null,arguments)},t._GatherNd=function(){return(t._GatherNd=t.asm.GatherNd).apply(null,arguments)},t._Greater=function(){return(t._Greater=t.asm.Greater).apply(null,arguments)},t._GreaterEqual=function(){return(t._GreaterEqual=t.asm.GreaterEqual).apply(null,arguments)},t._IsFinite=function(){return(t._IsFinite=t.asm.IsFinite).apply(null,arguments)},t._IsInf=function(){return(t._IsInf=t.asm.IsInf).apply(null,arguments)},t._IsNan=function(){return(t._IsNan=t.asm.IsNan).apply(null,arguments)},t._LRN=function(){return(t._LRN=t.asm.LRN).apply(null,arguments)},t._LRNGrad=function(){return(t._LRNGrad=t.asm.LRNGrad).apply(null,arguments)},t._LeakyRelu=function(){return(t._LeakyRelu=t.asm.LeakyRelu).apply(null,arguments)},t._Less=function(){return(t._Less=t.asm.Less).apply(null,arguments)},t._LessEqual=function(){return(t._LessEqual=t.asm.LessEqual).apply(null,arguments)},t._LinSpace=function(){return(t._LinSpace=t.asm.LinSpace).apply(null,arguments)},t._Log=function(){return(t._Log=t.asm.Log).apply(null,arguments)},t._Log1p=function(){return(t._Log1p=t.asm.Log1p).apply(null,arguments)},t._LogicalAnd=function(){return(t._LogicalAnd=t.asm.LogicalAnd).apply(null,arguments)},t._LogicalNot=function(){return(t._LogicalNot=t.asm.LogicalNot).apply(null,arguments)},t._LogicalOr=function(){return(t._LogicalOr=t.asm.LogicalOr).apply(null,arguments)},t._LogicalXor=function(){return(t._LogicalXor=t.asm.LogicalXor).apply(null,arguments)},t._Max=function(){return(t._Max=t.asm.Max).apply(null,arguments)},t._MaxPool=function(){return(t._MaxPool=t.asm.MaxPool).apply(null,arguments)},t._MaxPool3D=function(){return(t._MaxPool3D=t.asm.MaxPool3D).apply(null,arguments)},t._MaxPool3DGrad=function(){return(t._MaxPool3DGrad=t.asm.MaxPool3DGrad).apply(null,arguments)},t._MaxPoolGrad=function(){return(t._MaxPoolGrad=t.asm.MaxPoolGrad).apply(null,arguments)},t._MaxPoolWithArgmax=function(){return(t._MaxPoolWithArgmax=t.asm.MaxPoolWithArgmax).apply(null,arguments)},t._Maximum=function(){return(t._Maximum=t.asm.Maximum).apply(null,arguments)},t._Mean=function(){return(t._Mean=t.asm.Mean).apply(null,arguments)},t._Min=function(){return(t._Min=t.asm.Min).apply(null,arguments)},t._Minimum=function(){return(t._Minimum=t.asm.Minimum).apply(null,arguments)},t._MirrorPad=function(){return(t._MirrorPad=t.asm.MirrorPad).apply(null,arguments)},t._Mod=function(){return(t._Mod=t.asm.Mod).apply(null,arguments)},t._Multinomial=function(){return(t._Multinomial=t.asm.Multinomial).apply(null,arguments)},t._Multiply=function(){return(t._Multiply=t.asm.Multiply).apply(null,arguments)},t._Neg=function(){return(t._Neg=t.asm.Neg).apply(null,arguments)},t._NonMaxSuppressionV3=function(){return(t._NonMaxSuppressionV3=t.asm.NonMaxSuppressionV3).apply(null,arguments)},t._NonMaxSuppressionV4=function(){return(t._NonMaxSuppressionV4=t.asm.NonMaxSuppressionV4).apply(null,arguments)},t._NonMaxSuppressionV5=function(){return(t._NonMaxSuppressionV5=t.asm.NonMaxSuppressionV5).apply(null,arguments)},t._NotEqual=function(){return(t._NotEqual=t.asm.NotEqual).apply(null,arguments)},t._OneHot=function(){return(t._OneHot=t.asm.OneHot).apply(null,arguments)},t._PadV2=function(){return(t._PadV2=t.asm.PadV2).apply(null,arguments)},t._Pow=function(){return(t._Pow=t.asm.Pow).apply(null,arguments)},t._Prelu=function(){return(t._Prelu=t.asm.Prelu).apply(null,arguments)},t._Prod=function(){return(t._Prod=t.asm.Prod).apply(null,arguments)},t._RealDiv=function(){return(t._RealDiv=t.asm.RealDiv).apply(null,arguments)},t._Reciprocal=function(){return(t._Reciprocal=t.asm.Reciprocal).apply(null,arguments)},t._Relu=function(){return(t._Relu=t.asm.Relu).apply(null,arguments)},t._Relu6=function(){return(t._Relu6=t.asm.Relu6).apply(null,arguments)},t._ResizeBilinear=function(){return(t._ResizeBilinear=t.asm.ResizeBilinear).apply(null,arguments)},t._ResizeBilinearGrad=function(){return(t._ResizeBilinearGrad=t.asm.ResizeBilinearGrad).apply(null,arguments)},t._ResizeNearestNeighbor=function(){return(t._ResizeNearestNeighbor=t.asm.ResizeNearestNeighbor).apply(null,arguments)},t._ResizeNearestNeighborGrad=function(){return(t._ResizeNearestNeighborGrad=t.asm.ResizeNearestNeighborGrad).apply(null,arguments)},t._Reverse=function(){return(t._Reverse=t.asm.Reverse).apply(null,arguments)},t._RotateWithOffset=function(){return(t._RotateWithOffset=t.asm.RotateWithOffset).apply(null,arguments)},t._Round=function(){return(t._Round=t.asm.Round).apply(null,arguments)},t._Rsqrt=function(){return(t._Rsqrt=t.asm.Rsqrt).apply(null,arguments)},t._ScatterNd=function(){return(t._ScatterNd=t.asm.ScatterNd).apply(null,arguments)},t._SearchSorted=function(){return(t._SearchSorted=t.asm.SearchSorted).apply(null,arguments)},t._SelectV2=function(){return(t._SelectV2=t.asm.SelectV2).apply(null,arguments)},t._Selu=function(){return(t._Selu=t.asm.Selu).apply(null,arguments)},t._Sigmoid=function(){return(t._Sigmoid=t.asm.Sigmoid).apply(null,arguments)},t._Sign=function(){return(t._Sign=t.asm.Sign).apply(null,arguments)},t._Sin=function(){return(t._Sin=t.asm.Sin).apply(null,arguments)},t._Sinh=function(){return(t._Sinh=t.asm.Sinh).apply(null,arguments)},t._Softmax=function(){return(t._Softmax=t.asm.Softmax).apply(null,arguments)},t._Softplus=function(){return(t._Softplus=t.asm.Softplus).apply(null,arguments)},t._SparseFillEmptyRows=function(){return(t._SparseFillEmptyRows=t.asm.SparseFillEmptyRows).apply(null,arguments)},t._SparseReshape=function(){return(t._SparseReshape=t.asm.SparseReshape).apply(null,arguments)},t._SparseSegmentReduction=function(){return(t._SparseSegmentReduction=t.asm.SparseSegmentReduction).apply(null,arguments)},t._SparseToDense=function(){return(t._SparseToDense=t.asm.SparseToDense).apply(null,arguments)},t._Sqrt=function(){return(t._Sqrt=t.asm.Sqrt).apply(null,arguments)},t._Square=function(){return(t._Square=t.asm.Square).apply(null,arguments)},t._SquaredDifference=function(){return(t._SquaredDifference=t.asm.SquaredDifference).apply(null,arguments)},t._Step=function(){return(t._Step=t.asm.Step).apply(null,arguments)},t._StridedSlice=function(){return(t._StridedSlice=t.asm.StridedSlice).apply(null,arguments)},t._Sub=function(){return(t._Sub=t.asm.Sub).apply(null,arguments)},t._Sum=function(){return(t._Sum=t.asm.Sum).apply(null,arguments)},t._Tan=function(){return(t._Tan=t.asm.Tan).apply(null,arguments)},t._Tanh=function(){return(t._Tanh=t.asm.Tanh).apply(null,arguments)},t._TensorScatterUpdate=function(){return(t._TensorScatterUpdate=t.asm.TensorScatterUpdate).apply(null,arguments)},t._Tile=function(){return(t._Tile=t.asm.Tile).apply(null,arguments)},t._TopK=function(){return(t._TopK=t.asm.TopK).apply(null,arguments)},t._Transform=function(){return(t._Transform=t.asm.Transform).apply(null,arguments)},t._Transpose=function(){return(t._Transpose=t.asm.Transpose).apply(null,arguments)},t.__FusedMatMul=function(){return(t.__FusedMatMul=t.asm._FusedMatMul).apply(null,arguments)},t._malloc=function(){return(t._malloc=t.asm.malloc).apply(null,arguments)},t._free=function(){return(t._free=t.asm.free).apply(null,arguments)},t.___errno_location=function(){return(t.___errno_location=t.asm.__errno_location).apply(null,arguments)},t.stackSave=function(){return(At=t.stackSave=t.asm.stackSave).apply(null,arguments)}),Tn=t.stackRestore=function(){return(Tn=t.stackRestore=t.asm.stackRestore).apply(null,arguments)},xt=t.stackAlloc=function(){return(xt=t.stackAlloc=t.asm.stackAlloc).apply(null,arguments)};function En(I){function M(){nt||(nt=!0,t.calledRun=!0,!He&&(function Zt(){Re(Vt)}(),Te(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),function qt(){if(t.postRun)for("function"==typeof t.postRun&&(t.postRun=[t.postRun]);t.postRun.length;)I=t.postRun.shift(),oe.unshift(I);var I;Re(oe)}()))}I=I||Pt,pe>0||(function jt(){if(t.preRun)for("function"==typeof t.preRun&&(t.preRun=[t.preRun]);t.preRun.length;)I=t.preRun.shift(),zt.unshift(I);var I;Re(zt)}(),pe>0)||(t.setStatus?(t.setStatus("Running..."),setTimeout(function(){setTimeout(function(){t.setStatus("")},1),M()},1)):M())}if(t.dynCall_iijjiiii=function(){return(t.dynCall_iijjiiii=t.asm.dynCall_iijjiiii).apply(null,arguments)},t.dynCall_jiji=function(){return(t.dynCall_jiji=t.asm.dynCall_jiji).apply(null,arguments)},t.cwrap=function na(I,M,N,V){var q=(N=N||[]).every(L=>"number"===L||"boolean"===L);return"string"!==M&&q&&!V?ft(I):function(){return en(I,M,N,arguments)}},Pe=function I(){nt||En(),nt||(Pe=I)},t.preInit)for("function"==typeof t.preInit&&(t.preInit=[t.preInit]);t.preInit.length>0;)t.preInit.pop()();if(En(),ke&&(at={uncaughtException:process.listeners("uncaughtException").filter(function(I){return!ke.uncaughtException.indexOf(I)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(I){return!ke.unhandledRejection.indexOf(I)>-1})}),typeof re<"u")qe=re;else{if(!(typeof WasmBackendModuleThreadedSimd<"u"))throw new Error("Could not find wasm module in post.js");qe=WasmBackendModuleThreadedSimd}if(at){var zr=qe._dispose;qe._dispose=function(){zr(),at.uncaughtException.forEach(function(I){process.removeListener("uncaughtException",I)}),at.unhandledRejection.forEach(function(I){process.removeListener("unhandledRejection",I)})}}return re.ready});Tt.exports=o},9893:()=>{},8074:()=>{},45281:()=>{},97244:()=>{},13556:()=>{}}]);